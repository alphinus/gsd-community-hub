---
phase: 02-contribution-tracking
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/types/src/contribution.ts
  - packages/types/src/index.ts
  - packages/utils/src/contribution-hash.ts
  - packages/utils/src/score.ts
  - packages/utils/src/index.ts
  - packages/utils/tests/score.test.ts
  - packages/utils/tests/contribution-hash.test.ts
  - packages/utils/package.json
autonomous: true

must_haves:
  truths:
    - "ContributionData type mirrors the on-chain ContributionLeaf schema (developer, taskRef, verificationScore, timestamp, contentHash)"
    - "computeContributionLeafHash produces identical SHA-256 hash as the on-chain to_leaf_hash method for the same input data"
    - "calculateContributionScore returns 0n for zero tasks or zero time"
    - "calculateContributionScore uses BigInt for all intermediate calculations to prevent overflow"
    - "Score calculation produces deterministic results for the same inputs across environments"
  artifacts:
    - path: "packages/types/src/contribution.ts"
      provides: "ContributionData, ContributionRecord, ContributionScore types"
      exports: ["ContributionData", "ContributionRecord", "ContributionScore"]
    - path: "packages/utils/src/contribution-hash.ts"
      provides: "SHA-256 leaf hash computation matching on-chain serialization"
      exports: ["computeContributionLeafHash"]
    - path: "packages/utils/src/score.ts"
      provides: "Contribution score calculation with BigInt precision"
      exports: ["calculateContributionScore"]
    - path: "packages/utils/tests/score.test.ts"
      provides: "Score calculation test suite covering edge cases and overflow"
    - path: "packages/utils/tests/contribution-hash.test.ts"
      provides: "Contribution hash test suite verifying canonical serialization"
  key_links:
    - from: "packages/utils/src/contribution-hash.ts"
      to: "programs/gsd-hub/src/state/contribution.rs"
      via: "Identical serialization format (32+32+2+8+32 bytes, little-endian)"
      pattern: "106 bytes total"
    - from: "packages/utils/src/score.ts"
      to: "programs/gsd-hub/src/state/developer.rs"
      via: "Score stored as u64 on-chain, returned as bigint from calculation"
      pattern: "calculateContributionScore"
---

<objective>
Build the shared TypeScript packages for contribution types, content hash computation, and score calculation -- using TDD for the mathematical functions.

Purpose: These shared utilities are consumed by both the web app (API routes, UI) and scripts (webhook indexer, tree client). The hash computation MUST produce identical output to the on-chain Rust serialization+hashing, so tests are critical. The score calculation uses BigInt to prevent overflow for active developers.

Output: @gsd/types with contribution interfaces, @gsd/utils with tested hash and score functions.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-contribution-tracking/02-RESEARCH.md

Key existing files:
@packages/types/src/profile.ts
@packages/types/src/index.ts
@packages/utils/src/pda.ts
@packages/utils/src/hash.ts
@packages/utils/src/index.ts
@packages/utils/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contribution types and hash utility with tests</name>
  <files>
    packages/types/src/contribution.ts
    packages/types/src/index.ts
    packages/utils/src/contribution-hash.ts
    packages/utils/tests/contribution-hash.test.ts
    packages/utils/package.json
    packages/utils/src/index.ts
  </files>
  <action>
    **1. Create `packages/types/src/contribution.ts`:**

    Define the following TypeScript interfaces/types:

    ```typescript
    /** Mirrors the on-chain ContributionLeaf struct field-for-field */
    export interface ContributionData {
      developer: string;        // wallet address (base58)
      taskRef: string;          // hex-encoded 32-byte task reference hash
      verificationScore: number; // 0-10000 (representing 0.00-100.00%)
      timestamp: number;        // unix timestamp (seconds)
      contentHash: string;      // hex-encoded SHA-256 of off-chain content
    }

    /** Full contribution record as stored in the off-chain database */
    export interface ContributionRecord extends ContributionData {
      id: string;
      leafHash: string;         // hex-encoded 32-byte Merkle tree leaf hash
      leafIndex: number;        // position in Merkle tree
      treeAddress: string;      // Merkle tree public key (base58)
      transactionSignature: string; // on-chain tx signature (base58)
      description?: string;     // off-chain contribution description
      createdAt: Date;
    }

    /** Contribution score data for display */
    export interface ContributionScore {
      tasksCompleted: number;
      averageVerificationScore: number; // 0-100 (human-readable percentage)
      timeActiveDays: number;
      score: string;            // string representation of BigInt score
      scoreVersion: number;
    }
    ```

    **2. Update `packages/types/src/index.ts`:**

    Add `export * from './contribution.js';`

    **3. Create test file FIRST (TDD red phase): `packages/utils/tests/contribution-hash.test.ts`**

    Use Node.js built-in `test` runner (node:test) and `assert` (node:assert). Check if the project already uses a test framework for utils -- if so, follow that pattern. Otherwise, use node:test since utils has no test dependencies yet.

    Test cases:
    - **Known input -> known output:** Create a ContributionData with a known wallet address (use a fixed base58 string), known taskRef, score=5000, timestamp=1700000000, known contentHash. Compute the leaf hash. Assert it equals a known expected hash (compute this by hand or by running the test once in red-green to capture the deterministic output).
    - **Canonical serialization:** Verify the function produces exactly 106 bytes of serialized data before hashing:
      - Bytes 0-31: developer pubkey (decoded from base58)
      - Bytes 32-63: taskRef (decoded from hex)
      - Bytes 64-65: verificationScore as u16 LE
      - Bytes 66-73: timestamp as i64 LE (signed 64-bit little-endian)
      - Bytes 74-105: contentHash (decoded from hex)
    - **Deterministic:** Same input always produces same output (call twice, compare)
    - **Different inputs -> different outputs:** Change one field, verify hash changes

    **4. Implement `packages/utils/src/contribution-hash.ts` (TDD green phase):**

    ```typescript
    import { PublicKey } from "@solana/web3.js";

    export async function computeContributionLeafHash(
      contribution: ContributionData
    ): Promise<Uint8Array> {
      // Canonical serialization matching on-chain ContributionLeaf AnchorSerialize format
      const buffer = new Uint8Array(106);

      // developer: Pubkey (32 bytes)
      const pubkey = new PublicKey(contribution.developer);
      buffer.set(pubkey.toBytes(), 0);

      // task_ref: [u8; 32] (32 bytes from hex)
      const taskRef = hexToBytes(contribution.taskRef);
      buffer.set(taskRef, 32);

      // verification_score: u16 LE (2 bytes)
      const view = new DataView(buffer.buffer);
      view.setUint16(64, contribution.verificationScore, true); // true = little-endian

      // timestamp: i64 LE (8 bytes)
      // Use BigInt for 64-bit signed integer
      const timestampBigInt = BigInt(contribution.timestamp);
      view.setBigInt64(66, timestampBigInt, true);

      // content_hash: [u8; 32] (32 bytes from hex)
      const contentHash = hexToBytes(contribution.contentHash);
      buffer.set(contentHash, 74);

      // SHA-256 hash of the serialized data
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      return new Uint8Array(hashBuffer);
    }
    ```

    Include helper functions: `hexToBytes(hex: string): Uint8Array` and `bytesToHex(bytes: Uint8Array): string`.

    Also export `serializeContributionLeaf(contribution: ContributionData): Uint8Array` separately (the 106-byte buffer before hashing) -- the indexer needs this to emit via noop.

    Import `ContributionData` from `@gsd/types`.

    **5. Update `packages/utils/src/index.ts`:**

    Add `export * from './contribution-hash.js';`

    **6. Update `packages/utils/package.json`:**

    Add a test script: `"test": "node --test tests/*.test.ts"` (or use tsx if needed for TypeScript execution). Check what test tooling the project uses -- if ts-mocha is available at root, use that pattern instead. The key is that tests run.
  </action>
  <verify>
    Run the contribution hash tests. All test cases must pass:
    - `cd packages/utils && pnpm test` (or equivalent)
    - Verify deterministic output
    - Verify serialization is exactly 106 bytes
    - Verify different inputs produce different hashes
  </verify>
  <done>
    ContributionData, ContributionRecord, and ContributionScore types exported from @gsd/types. computeContributionLeafHash and serializeContributionLeaf exported from @gsd/utils. All hash tests pass, confirming canonical serialization matching on-chain format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement score calculation with TDD</name>
  <files>
    packages/utils/src/score.ts
    packages/utils/tests/score.test.ts
    packages/utils/src/index.ts
  </files>
  <action>
    **TDD RED phase -- write tests first:**

    **1. Create `packages/utils/tests/score.test.ts`:**

    Test cases for `calculateContributionScore(tasksCompleted, totalVerificationScore, timeActiveDays) -> bigint`:

    - **Zero tasks returns 0n:** `calculateContributionScore(0, 0, 0)` === `0n`
    - **Zero time returns 0n:** `calculateContributionScore(10, 50000, 0)` === `0n`
    - **Zero score returns 0n:** `calculateContributionScore(10, 0, 30)` === `0n`
    - **Simple case:** 1 task, score 10000 (100%), 1 day:
      - avgScore = 10000/1 = 10000
      - product = 1 * 10000 * 1 = 10000
      - sqrt(10000 * 1e12) = sqrt(1e16) = 1e8 = 100000000n
      - Assert: `calculateContributionScore(1, 10000, 1)` === `100000000n`
    - **Moderate developer:** 50 tasks, total score 400000 (avg 8000 = 80%), 90 days:
      - avgScore = 400000/50 = 8000
      - product = 50 * 8000 * 90 = 36000000
      - sqrt(36000000 * 1e12) = sqrt(3.6e19) â‰ˆ 6000000000n (approximately, verify exact)
      - Assert: result is in expected range (BigInt integer sqrt should be deterministic)
    - **Very active developer (overflow test):** 10000 tasks, total score 100000000 (avg 10000), 365 days:
      - product = 10000 * 10000 * 365 = 36500000000
      - Must not overflow -- BigInt handles this
      - Result should be a positive bigint > 0n
    - **Deterministic:** Same inputs always produce same output (call twice, compare)
    - **Monotonic increase:** More tasks with same avg score and time -> higher score

    **TDD GREEN phase -- implement:**

    **2. Create `packages/utils/src/score.ts`:**

    ```typescript
    /**
     * Calculate contribution score using the formula:
     * score = sqrt(tasks_completed * avg_verification_score * time_active_days)
     *
     * All intermediate calculations use BigInt to prevent overflow.
     * The result is scaled by 1e6 (multiply product by 1e12 before sqrt).
     * This matches the on-chain u64 storage format.
     *
     * @param tasksCompleted - Number of completed tasks
     * @param totalVerificationScore - Sum of all verification scores (each 0-10000)
     * @param timeActiveDays - Days since first contribution
     * @returns Score as BigInt (scaled by 1e6), or 0n if any input is zero
     */
    export function calculateContributionScore(
      tasksCompleted: number,
      totalVerificationScore: number,
      timeActiveDays: number,
    ): bigint {
      if (tasksCompleted === 0 || totalVerificationScore === 0 || timeActiveDays === 0) {
        return 0n;
      }

      // Average verification score (integer division)
      const avgScore = Math.floor(totalVerificationScore / tasksCompleted);

      // Product using BigInt to prevent overflow
      const product = BigInt(tasksCompleted) * BigInt(avgScore) * BigInt(timeActiveDays);

      // Scale by 1e12 before sqrt to get 1e6 precision in result
      const scaled = product * 1_000_000_000_000n;

      return bigintSqrt(scaled);
    }

    /** Integer square root using Newton's method for BigInt */
    function bigintSqrt(n: bigint): bigint {
      if (n < 0n) throw new Error("Square root of negative number");
      if (n === 0n) return 0n;
      let x = n;
      let y = (x + 1n) / 2n;
      while (y < x) {
        x = y;
        y = (x + n / x) / 2n;
      }
      return x;
    }
    ```

    Export `bigintSqrt` as well (useful for tests and debugging).

    **3. Update `packages/utils/src/index.ts`:**

    Add `export * from './score.js';`

    **TDD REFACTOR phase:**

    Review the implementation for clarity. Ensure JSDoc comments document the scaling factor and formula. Ensure the function signature matches what the webhook indexer and API will call.
  </action>
  <verify>
    Run the score calculation tests. All test cases must pass:
    - Zero inputs return 0n
    - Simple case produces exact expected BigInt value
    - Overflow test completes without error
    - Results are deterministic and monotonically increasing with more contributions
  </verify>
  <done>
    calculateContributionScore function exported from @gsd/utils with BigInt precision. All edge cases tested: zero inputs, simple case with exact expected value, overflow scenario with 10K tasks. bigintSqrt helper using Newton's method tested and exported. TDD red-green-refactor cycle complete.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` at monorepo root succeeds (or `npx tsc --noEmit` in packages/)
2. All contribution hash tests pass
3. All score calculation tests pass
4. `packages/types/src/index.ts` exports ContributionData, ContributionRecord, ContributionScore
5. `packages/utils/src/index.ts` exports computeContributionLeafHash, serializeContributionLeaf, calculateContributionScore, bigintSqrt
</verification>

<success_criteria>
- @gsd/types exports ContributionData (matching on-chain ContributionLeaf), ContributionRecord, and ContributionScore interfaces
- computeContributionLeafHash produces deterministic 32-byte SHA-256 hash from canonical 106-byte serialization
- calculateContributionScore handles zero inputs, large inputs, and produces correct BigInt results
- All tests pass with deterministic results
</success_criteria>

<output>
After completion, create `.planning/phases/02-contribution-tracking/02-02-SUMMARY.md`
</output>
