---
phase: 02-contribution-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - programs/gsd-hub/src/state/contribution.rs
  - programs/gsd-hub/src/state/merkle_tree.rs
  - programs/gsd-hub/src/state/developer.rs
  - programs/gsd-hub/src/state/mod.rs
  - programs/gsd-hub/src/cpi/compression.rs
  - programs/gsd-hub/src/cpi/noop.rs
  - programs/gsd-hub/src/cpi/mod.rs
  - programs/gsd-hub/src/errors.rs
  - programs/gsd-hub/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "ContributionLeaf struct serializes to exactly 106 bytes with developer (32), task_ref (32), verification_score (2), timestamp (8), content_hash (32)"
    - "ContributionTreeConfig PDA stores tree address, authority, depth, and creation metadata"
    - "DeveloperProfile struct extends from 89 to 130 bytes with contribution score fields appended at the end (no field reordering)"
    - "Raw CPI helper can construct a valid append instruction for spl-account-compression program"
    - "Raw CPI helper can construct a valid noop log instruction for spl-noop program"
  artifacts:
    - path: "programs/gsd-hub/src/state/contribution.rs"
      provides: "ContributionLeaf data struct (106 bytes)"
      contains: "ContributionLeaf"
    - path: "programs/gsd-hub/src/state/merkle_tree.rs"
      provides: "ContributionTreeConfig PDA account"
      contains: "ContributionTreeConfig"
    - path: "programs/gsd-hub/src/state/developer.rs"
      provides: "Extended DeveloperProfile with score fields (130 bytes)"
      contains: "contribution_score"
    - path: "programs/gsd-hub/src/cpi/compression.rs"
      provides: "Raw CPI to spl-account-compression append"
      contains: "append_leaf"
    - path: "programs/gsd-hub/src/cpi/noop.rs"
      provides: "Raw CPI to spl-noop for data logging"
      contains: "wrap_application_data"
  key_links:
    - from: "programs/gsd-hub/src/cpi/compression.rs"
      to: "spl-account-compression program (cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK)"
      via: "solana_program::invoke with raw instruction bytes"
      pattern: "ACCOUNT_COMPRESSION_PROGRAM_ID"
    - from: "programs/gsd-hub/src/cpi/noop.rs"
      to: "spl-noop program (noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV)"
      via: "solana_program::invoke with serialized contribution data"
      pattern: "NOOP_PROGRAM_ID"
---

<objective>
Build the on-chain state structs and CPI helper modules that form the foundation for all contribution tracking instructions.

Purpose: Every subsequent on-chain instruction (init_tree, record_contribution, update_score) depends on these state definitions and CPI helpers. This is the data layer of the contribution tracking system.

Output: Rust state modules (ContributionLeaf, ContributionTreeConfig, extended DeveloperProfile) and CPI helper modules (compression, noop) that compile cleanly with `anchor build`.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-contribution-tracking/02-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md

Key existing files:
@programs/gsd-hub/src/lib.rs
@programs/gsd-hub/src/state/developer.rs
@programs/gsd-hub/src/state/mod.rs
@programs/gsd-hub/src/errors.rs
@programs/gsd-hub/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contribution state structs and extend DeveloperProfile</name>
  <files>
    programs/gsd-hub/src/state/contribution.rs
    programs/gsd-hub/src/state/merkle_tree.rs
    programs/gsd-hub/src/state/developer.rs
    programs/gsd-hub/src/state/mod.rs
    programs/gsd-hub/src/errors.rs
  </files>
  <action>
    **1. Create `programs/gsd-hub/src/state/contribution.rs`:**

    Define `ContributionLeaf` struct with `AnchorSerialize`/`AnchorDeserialize` derives (NOT an `#[account]` -- this is leaf data, not a PDA):
    - `developer: Pubkey` (32 bytes) -- wallet that made the contribution
    - `task_ref: [u8; 32]` (32 bytes) -- SHA-256 hash of task identifier
    - `verification_score: u16` (2 bytes) -- 0-10000 representing 0.00-100.00%
    - `timestamp: i64` (8 bytes) -- Unix timestamp of contribution
    - `content_hash: [u8; 32]` (32 bytes) -- SHA-256 hash of off-chain contribution content
    - Total serialized: 106 bytes

    Add a `to_leaf_hash(&self) -> [u8; 32]` method that:
    - Serializes the struct via `AnchorSerialize::try_to_vec()`
    - Hashes with `anchor_lang::solana_program::hash::hash()`
    - Returns the 32-byte hash (this becomes the Merkle tree leaf)

    **2. Create `programs/gsd-hub/src/state/merkle_tree.rs`:**

    Define `ContributionTreeConfig` as an `#[account]` with `#[derive(InitSpace)]`:
    - `authority: Pubkey` (32 bytes) -- PDA or keypair that can append leaves
    - `merkle_tree: Pubkey` (32 bytes) -- address of the concurrent Merkle tree account
    - `total_contributions: u64` (8 bytes) -- count of appended leaves
    - `bump: u8` (1 byte) -- PDA bump
    - `created_at: i64` (8 bytes) -- Unix timestamp
    - Total: 8 (discriminator) + 32 + 32 + 8 + 1 + 8 = 89 bytes

    PDA seeds: `[b"contribution_tree", merkle_tree.key().as_ref()]`

    **3. Extend `programs/gsd-hub/src/state/developer.rs`:**

    CRITICAL: Append new fields at the END of the struct. Do NOT reorder existing fields. This ensures backward compatibility with Phase 1 accounts via realloc.

    Add after `profile_hash`:
    - `tasks_completed: u32` (4 bytes)
    - `total_verification_score: u64` (8 bytes) -- sum of all verification scores for average calculation
    - `time_active_days: u32` (4 bytes) -- days since first contribution
    - `contribution_score: u64` (8 bytes) -- scaled by 1e6 for fixed-point precision
    - `first_contribution_at: i64` (8 bytes) -- unix timestamp, 0 = no contributions yet
    - `last_contribution_at: i64` (8 bytes) -- unix timestamp
    - `score_version: u8` (1 byte) -- for future formula changes, starts at 1

    New total: 89 + 4 + 8 + 4 + 8 + 8 + 8 + 1 = 130 bytes (with discriminator: 8 + 130 = 138)

    NOTE: The `#[derive(InitSpace)]` will automatically compute the new INIT_SPACE. Existing `register_developer` instruction does NOT need changes -- it will still init with the full struct size (new fields zero-initialized). The realloc for existing accounts happens in `update_score` instruction (Plan 03).

    **4. Update `programs/gsd-hub/src/state/mod.rs`:**

    Add `pub mod contribution;` and `pub mod merkle_tree;` with `pub use` re-exports.

    **5. Update `programs/gsd-hub/src/errors.rs`:**

    Add contribution-related error codes:
    - `InvalidVerificationScore` -- "Verification score must be 0-10000"
    - `TreeFull` -- "Contribution tree is full"
    - `InvalidTreeAuthority` -- "Invalid tree authority"
    - `InvalidContributionData` -- "Invalid contribution data"
    - `ScoreOverflow` -- "Contribution score calculation overflow"
  </action>
  <verify>
    Run `anchor build` from the project root. The program must compile without errors. Verify:
    - `grep -c "ContributionLeaf" programs/gsd-hub/src/state/contribution.rs` returns >= 1
    - `grep -c "ContributionTreeConfig" programs/gsd-hub/src/state/merkle_tree.rs` returns >= 1
    - `grep -c "contribution_score" programs/gsd-hub/src/state/developer.rs` returns >= 1
    - `grep -c "InvalidVerificationScore" programs/gsd-hub/src/errors.rs` returns >= 1
  </verify>
  <done>
    ContributionLeaf (106 bytes) serializes correctly with to_leaf_hash method. ContributionTreeConfig PDA stores tree metadata. DeveloperProfile extends to 130 bytes with contribution score fields appended at end. All new error codes defined. Program compiles with `anchor build`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create raw CPI helper modules for spl-account-compression and spl-noop</name>
  <files>
    programs/gsd-hub/src/cpi/compression.rs
    programs/gsd-hub/src/cpi/noop.rs
    programs/gsd-hub/src/cpi/mod.rs
    programs/gsd-hub/src/lib.rs
  </files>
  <action>
    **IMPORTANT:** Do NOT add `spl-account-compression` or `spl-noop` Rust crates to Cargo.toml. The spl-account-compression crate requires anchor-lang ^0.31 which conflicts with 0.32.1. Use raw CPI via `solana_program::invoke` / `invoke_signed` exclusively.

    **1. Create `programs/gsd-hub/src/cpi/compression.rs`:**

    Define constants:
    - `ACCOUNT_COMPRESSION_PROGRAM_ID: Pubkey` = `cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK`
    - `NOOP_PROGRAM_ID: Pubkey` = `noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV`

    Use `solana_program::pubkey!()` macro for compile-time Pubkey creation (available via `anchor_lang::solana_program`).

    Implement `append_leaf` function:
    ```
    pub fn append_leaf<'info>(
        merkle_tree: &AccountInfo<'info>,
        authority: &AccountInfo<'info>,
        noop_program: &AccountInfo<'info>,
        compression_program: &AccountInfo<'info>,
        leaf: [u8; 32],
        signer_seeds: Option<&[&[&[u8]]]>,
    ) -> Result<()>
    ```

    The instruction data layout for spl-account-compression `append`:
    - First 8 bytes: Anchor discriminator = `sha256("global:append")[..8]`
    - Next 32 bytes: the leaf data

    Use `anchor_lang::solana_program::hash::hash(b"global:append").to_bytes()[..8]` for the discriminator.

    Account metas for append:
    1. `merkle_tree` (writable, not signer)
    2. `authority` (not writable, signer)
    3. `noop_program` (not writable, not signer)

    If `signer_seeds` is `Some`, use `invoke_signed`. If `None`, use `invoke`. This supports both PDA authority (invoke_signed) and keypair authority (invoke).

    Also implement `init_empty_merkle_tree` function for completeness (used by init_contribution_tree instruction in Plan 03):
    - Discriminator: `sha256("global:init_empty_merkle_tree")[..8]`
    - Data: discriminator + max_depth (u32 LE) + max_buffer_size (u32 LE)
    - Accounts: merkle_tree (writable), authority (signer), noop_program, compression_program (for logs)

    NOTE on discriminators: The spl-account-compression program uses Anchor-style discriminators. Verify the instruction names match the deployed IDL. The TypeScript SDK uses `createInitEmptyMerkleTreeIx` which maps to `init_empty_merkle_tree`, and `createAppendIx` which maps to `append`. If the discriminators don't match during testing (Plan 03), the executor should fetch the IDL via `anchor idl fetch cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK --provider.cluster devnet` and adjust.

    **2. Create `programs/gsd-hub/src/cpi/noop.rs`:**

    Implement `wrap_application_data` function:
    ```
    pub fn wrap_application_data<'info>(
        noop_program: &AccountInfo<'info>,
        data: Vec<u8>,
    ) -> Result<()>
    ```

    The spl-noop program simply logs whatever data is passed in the instruction data field. No discriminator needed -- the entire instruction data IS the logged data. This is confirmed by the noop program source (it calls `sol_log_data` on the instruction data).

    The instruction:
    - `program_id`: NOOP_PROGRAM_ID
    - `accounts`: empty (no accounts needed)
    - `data`: the serialized contribution data (the full ContributionLeaf bytes, not the hash)

    This is crucial: the FULL contribution data (106 bytes) is emitted via noop so the off-chain indexer can reconstruct contributions from transaction logs. The 32-byte hash goes into the Merkle tree; the full data goes into noop logs.

    **3. Create `programs/gsd-hub/src/cpi/mod.rs`:**

    Export both modules with `pub use`.

    **4. Update `programs/gsd-hub/src/lib.rs`:**

    Add `pub mod cpi;` module declaration. Do NOT add any new instruction endpoints yet (that is Plan 03).
  </action>
  <verify>
    Run `anchor build` from the project root. The program must compile without errors. Verify:
    - `grep -c "ACCOUNT_COMPRESSION_PROGRAM_ID" programs/gsd-hub/src/cpi/compression.rs` returns >= 1
    - `grep -c "NOOP_PROGRAM_ID" programs/gsd-hub/src/cpi/compression.rs` returns >= 1
    - `grep -c "append_leaf" programs/gsd-hub/src/cpi/compression.rs` returns >= 1
    - `grep -c "wrap_application_data" programs/gsd-hub/src/cpi/noop.rs` returns >= 1
    - `grep -c "pub mod cpi" programs/gsd-hub/src/lib.rs` returns >= 1
    - No `spl-account-compression` or `spl-noop` in programs/gsd-hub/Cargo.toml dependencies
  </verify>
  <done>
    Raw CPI helper for spl-account-compression supports append_leaf and init_empty_merkle_tree via invoke/invoke_signed. Raw CPI helper for spl-noop emits full contribution data via wrap_application_data. No external Rust crate dependencies added. Program compiles cleanly with `anchor build`.
  </done>
</task>

</tasks>

<verification>
1. `anchor build` succeeds without errors or warnings (beyond existing ones)
2. `grep -r "spl-account-compression\|spl-noop" programs/gsd-hub/Cargo.toml` returns empty (no forbidden crate deps)
3. All new state structs derive `AnchorSerialize` and `AnchorDeserialize`
4. DeveloperProfile first 5 fields unchanged (authority, bump, created_at, updated_at, profile_hash) for backward compatibility
5. Generated IDL at `target/idl/gsd_hub.json` includes the new account types
</verification>

<success_criteria>
- ContributionLeaf (106 bytes), ContributionTreeConfig PDA (89 bytes), and extended DeveloperProfile (130 bytes) all compile
- Raw CPI modules for spl-account-compression and spl-noop compile without external crate dependencies
- Existing register_developer and update_profile_hash tests still pass (no breaking changes)
- `anchor build` produces updated IDL with new types
</success_criteria>

<output>
After completion, create `.planning/phases/02-contribution-tracking/02-01-SUMMARY.md`
</output>
