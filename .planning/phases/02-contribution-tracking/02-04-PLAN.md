---
phase: 02-contribution-tracking
plan: 04
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - apps/web/prisma/schema.prisma
  - apps/web/app/api/webhooks/helius/route.ts
  - apps/web/lib/contributions/indexer.ts
  - scripts/setup-helius-webhook.ts
  - apps/web/.env.example
autonomous: true
user_setup:
  - service: helius
    why: "Webhook delivery for on-chain event sync"
    env_vars:
      - name: HELIUS_API_KEY
        source: "Helius Dashboard -> API Keys (https://dev.helius.xyz/)"
      - name: HELIUS_WEBHOOK_AUTH
        source: "Generate a random secret string (e.g., openssl rand -hex 32)"
    dashboard_config:
      - task: "Create a free Helius account"
        location: "https://dev.helius.xyz/"

must_haves:
  truths:
    - "Prisma Contribution model stores all fields needed for contribution history display and on-chain verification"
    - "Helius webhook receiver authenticates requests, processes contribution events, and stores them in PostgreSQL with transaction signature idempotency"
    - "Duplicate webhook deliveries are silently ignored (no duplicate contribution records)"
    - "Webhook setup script creates a Helius webhook monitoring the gsd-hub program on devnet"
  artifacts:
    - path: "apps/web/prisma/schema.prisma"
      provides: "Contribution model with idempotency key and wallet index"
      contains: "model Contribution"
    - path: "apps/web/app/api/webhooks/helius/route.ts"
      provides: "POST endpoint receiving Helius enhanced transaction webhooks"
      exports: ["POST"]
    - path: "apps/web/lib/contributions/indexer.ts"
      provides: "Webhook payload processing and Prisma upsert logic"
      exports: ["processContributionEvent"]
    - path: "scripts/setup-helius-webhook.ts"
      provides: "CLI script to create Helius webhook via REST API"
  key_links:
    - from: "apps/web/app/api/webhooks/helius/route.ts"
      to: "apps/web/lib/contributions/indexer.ts"
      via: "processContributionEvent function call"
      pattern: "processContributionEvent"
    - from: "apps/web/lib/contributions/indexer.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "prisma.contribution.upsert with transactionSignature as unique key"
      pattern: "prisma\\.contribution\\.upsert"
    - from: "scripts/setup-helius-webhook.ts"
      to: "Helius REST API"
      via: "POST https://api.helius.xyz/v0/webhooks"
      pattern: "helius\\.xyz/v0/webhooks"
---

<objective>
Build the off-chain database model and Helius webhook infrastructure that syncs on-chain contribution events to PostgreSQL.

Purpose: The off-chain database provides fast queries for the contribution history UI. The Helius webhook ensures that every on-chain contribution appears in the database within seconds (INFR-05: <3 second sync target). Transaction signature idempotency prevents duplicate records from webhook retries.

Output: Prisma Contribution model, webhook receiver API route, indexer logic, and webhook setup script.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-contribution-tracking/02-RESEARCH.md
@.planning/phases/02-contribution-tracking/02-02-SUMMARY.md

Key existing files:
@apps/web/prisma/schema.prisma
@apps/web/lib/db/prisma.ts (or wherever the Prisma singleton is)
@apps/web/.env.example (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Prisma Contribution model and Helius webhook receiver</name>
  <files>
    apps/web/prisma/schema.prisma
    apps/web/app/api/webhooks/helius/route.ts
    apps/web/lib/contributions/indexer.ts
    apps/web/.env.example
  </files>
  <action>
    **1. Update `apps/web/prisma/schema.prisma`:**

    Add the Contribution model:
    ```prisma
    model Contribution {
      id                   String   @id @default(cuid())
      walletAddress        String
      taskRef              String   // hex-encoded 32-byte task reference
      verificationScore    Int      // 0-10000
      contentHash          String   // hex-encoded SHA-256 of off-chain content
      leafHash             String   // hex-encoded SHA-256 Merkle tree leaf hash
      leafIndex            Int      // position in Merkle tree
      treeAddress          String   // Merkle tree public key (base58)
      transactionSignature String   @unique // on-chain tx sig (idempotency key)
      description          String?  // off-chain contribution description
      createdAt            DateTime @default(now())

      user                 User     @relation(fields: [walletAddress], references: [walletAddress])

      @@index([walletAddress])
      @@index([treeAddress, leafIndex])
    }
    ```

    Add `contributions Contribution[]` relation to the existing User model.

    Run `npx prisma generate` to regenerate the client. Do NOT run `npx prisma db push` -- that is a user setup step documented in user_setup.

    **2. Create `apps/web/lib/contributions/indexer.ts`:**

    This module processes webhook payloads and stores contributions in PostgreSQL.

    ```typescript
    import { prisma } from "@/lib/db/prisma";
    import { ContributionData } from "@gsd/types";
    import { computeContributionLeafHash } from "@gsd/utils";
    ```

    Key function: `processContributionEvent(tx: EnhancedTransaction): Promise<void>`

    The Helius enhanced transaction webhook payload structure (relevant fields):
    ```typescript
    interface EnhancedTransaction {
      signature: string;
      type: string;
      timestamp: number;
      accountData: Array<{ account: string; nativeBalanceChange: number }>;
      instructions: Array<{
        programId: string;
        accounts: string[];
        data: string; // base58-encoded instruction data
        innerInstructions: Array<{
          programId: string;
          accounts: string[];
          data: string;
        }>;
      }>;
    }
    ```

    Processing logic:
    1. Check if `tx.signature` already exists in Contribution table (idempotency). If yes, return early.
    2. Find instructions where `programId === PROGRAM_ID` (from env `NEXT_PUBLIC_PROGRAM_ID`)
    3. For `record_contribution` instructions, extract the contribution data:
       - The instruction data contains the Anchor discriminator (8 bytes) + args (developer, task_ref, verification_score, content_hash)
       - ALTERNATIVELY: Parse the noop inner instruction which contains the full serialized ContributionLeaf (106 bytes). This is easier because noop data is the raw serialized struct.
    4. Look for the noop inner instruction: find inner instructions where `programId === NOOP_PROGRAM_ID`. The data field contains the serialized ContributionLeaf.
    5. Deserialize the noop data: decode from base58, then parse the 106 bytes (32 developer + 32 task_ref + 2 score + 8 timestamp + 32 content_hash).
    6. Compute the leaf hash using `computeContributionLeafHash` to verify integrity.
    7. Upsert to database:
       ```typescript
       await prisma.contribution.upsert({
         where: { transactionSignature: tx.signature },
         create: {
           walletAddress: contribution.developer,
           taskRef: bytesToHex(contribution.taskRef),
           verificationScore: contribution.verificationScore,
           contentHash: bytesToHex(contribution.contentHash),
           leafHash: bytesToHex(leafHash),
           leafIndex: treeConfig.totalContributions - 1, // from account data
           treeAddress: treeAddress,
           transactionSignature: tx.signature,
         },
         update: {}, // no-op on duplicate
       });
       ```

    NOTE: The exact parsing of enhanced transaction data may need adjustment during implementation. The enhanced webhook format includes parsed instruction data. If parsing the raw instruction data is too complex, fall back to parsing the noop log data which is a simpler 106-byte struct.

    Also export `parseContributionFromNoop(noopData: Uint8Array): ContributionData` as a reusable parser.

    **3. Create `apps/web/app/api/webhooks/helius/route.ts`:**

    ```typescript
    import { NextRequest, NextResponse } from "next/server";
    import { processContributionEvent } from "@/lib/contributions/indexer";

    const WEBHOOK_AUTH = process.env.HELIUS_WEBHOOK_AUTH;
    const PROGRAM_ID = process.env.NEXT_PUBLIC_PROGRAM_ID;

    export async function POST(req: NextRequest) {
      // 1. Verify auth header
      const authHeader = req.headers.get("authorization");
      if (!WEBHOOK_AUTH || authHeader !== WEBHOOK_AUTH) {
        return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      }

      // 2. Parse payload
      let payload: any[];
      try {
        payload = await req.json();
      } catch {
        return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
      }

      // 3. Ensure it's an array (Helius sends arrays of transactions)
      if (!Array.isArray(payload)) {
        payload = [payload];
      }

      // 4. Process each transaction
      let processed = 0;
      for (const tx of payload) {
        try {
          // Only process transactions involving our program
          const involvedAccounts = tx.accountData?.map((a: any) => a.account) ?? [];
          if (involvedAccounts.includes(PROGRAM_ID) ||
              tx.instructions?.some((ix: any) => ix.programId === PROGRAM_ID)) {
            await processContributionEvent(tx);
            processed++;
          }
        } catch (error) {
          // Log error but continue processing other transactions
          console.error(`Webhook processing error for tx ${tx.signature}:`, error);
        }
      }

      return NextResponse.json({ received: true, processed });
    }
    ```

    **4. Update `apps/web/.env.example` (create if doesn't exist):**

    Add:
    ```
    # Helius (Phase 2: Contribution Tracking)
    HELIUS_API_KEY=your_helius_api_key
    HELIUS_WEBHOOK_AUTH=your_webhook_auth_secret
    ```
  </action>
  <verify>
    1. `npx prisma generate` succeeds (in apps/web/)
    2. `npx prisma validate` succeeds (in apps/web/)
    3. Verify Contribution model exists: `grep -c "model Contribution" apps/web/prisma/schema.prisma` returns 1
    4. Verify idempotency key: `grep -c "transactionSignature String   @unique" apps/web/prisma/schema.prisma` returns 1
    5. Verify webhook route exports POST: `grep -c "export async function POST" apps/web/app/api/webhooks/helius/route.ts` returns 1
    6. TypeScript compiles: `cd apps/web && npx tsc --noEmit` (or at least no type errors in new files)
  </verify>
  <done>
    Prisma Contribution model with unique transactionSignature for idempotency, wallet index for history queries. Webhook receiver authenticates via HELIUS_WEBHOOK_AUTH header, processes enhanced transaction payloads, extracts contribution data from noop logs, upserts to PostgreSQL. Duplicate webhook deliveries safely ignored.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Helius webhook setup script</name>
  <files>
    scripts/setup-helius-webhook.ts
  </files>
  <action>
    Create `scripts/setup-helius-webhook.ts` following the existing CLI script pattern from `scripts/setup-multisig.ts` (argument validation, --help, clear output formatting, environment variable documentation).

    **Script purpose:** Creates a Helius webhook via REST API that monitors the gsd-hub program for contribution events.

    **Usage:**
    ```
    npx tsx scripts/setup-helius-webhook.ts --webhook-url https://your-app.vercel.app/api/webhooks/helius [--network devnet|mainnet]
    ```

    **Environment variables required:**
    - `HELIUS_API_KEY` -- Helius API key
    - `HELIUS_WEBHOOK_AUTH` -- secret string for webhook auth header
    - `NEXT_PUBLIC_PROGRAM_ID` -- gsd-hub program ID to monitor

    **Implementation:**

    1. Parse args: `--webhook-url` (required), `--network` (optional, default "devnet")
    2. Validate env vars exist
    3. Determine webhook type: "enhancedDevnet" for devnet, "enhanced" for mainnet
    4. POST to Helius API:
       ```
       POST https://api.helius.xyz/v0/webhooks?api-key=${HELIUS_API_KEY}
       Body: {
         webhookURL: webhookUrl,
         transactionTypes: ["ANY"],
         accountAddresses: [PROGRAM_ID],
         webhookType: webhookType,
         authHeader: HELIUS_WEBHOOK_AUTH
       }
       ```
    5. On success: print webhook ID, URL, and monitoring details
    6. On failure: print error message with troubleshooting hints

    **Also add a "list" subcommand:**
    ```
    npx tsx scripts/setup-helius-webhook.ts --list
    ```
    GET to `https://api.helius.xyz/v0/webhooks?api-key=${HELIUS_API_KEY}` -- lists all configured webhooks.

    **Help text:**
    ```
    Usage: npx tsx scripts/setup-helius-webhook.ts [options]

    Create a Helius webhook to monitor gsd-hub program events.

    Options:
      --webhook-url <url>  The public URL for webhook delivery (required)
      --network <network>  Network: devnet or mainnet (default: devnet)
      --list               List all configured webhooks
      --help               Show this help message

    Environment variables:
      HELIUS_API_KEY         Helius API key (https://dev.helius.xyz/)
      HELIUS_WEBHOOK_AUTH    Secret for webhook authentication
      NEXT_PUBLIC_PROGRAM_ID Program ID to monitor

    Example:
      npx tsx scripts/setup-helius-webhook.ts --webhook-url https://myapp.vercel.app/api/webhooks/helius
    ```

    Use plain `fetch` (available in Node 18+). Do NOT import helius-sdk (version conflict with web3.js v1 per research).
  </action>
  <verify>
    1. `npx tsx scripts/setup-helius-webhook.ts --help` prints usage information
    2. Script validates required env vars and shows clear error when missing
    3. No import of `helius-sdk` anywhere in the file
    4. File follows same CLI pattern as existing scripts (setup-multisig.ts, log-upgrade.ts)
  </verify>
  <done>
    Helius webhook setup script creates webhooks via REST API (no SDK dependency). Supports --webhook-url, --network (devnet/mainnet), --list subcommand. Validates env vars with clear error messages. Follows existing CLI script conventions.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes in apps/web/
2. `npx prisma generate` produces updated client with Contribution model
3. Webhook route compiles and exports POST handler
4. Indexer imports from @gsd/types and @gsd/utils (cross-package dependency works)
5. Setup script runs with --help flag
6. No `helius-sdk` imported anywhere in the codebase
</verification>

<success_criteria>
- Contribution model in Prisma with unique transactionSignature constraint for idempotency
- Webhook receiver authenticates, processes enhanced transactions, extracts contribution data from noop logs
- Indexer upserts contributions (duplicate-safe) with proper wallet association
- Setup script creates Helius webhooks via REST API with proper devnet/mainnet webhook type
- All TypeScript files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-contribution-tracking/02-04-SUMMARY.md`
</output>
