---
phase: 02-contribution-tracking
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - programs/gsd-hub/src/instructions/init_contribution_tree.rs
  - programs/gsd-hub/src/instructions/record_contribution.rs
  - programs/gsd-hub/src/instructions/update_score.rs
  - programs/gsd-hub/src/instructions/mod.rs
  - programs/gsd-hub/src/lib.rs
  - programs/gsd-hub/tests/contribution.test.ts
autonomous: true

must_haves:
  truths:
    - "init_contribution_tree instruction creates a ContributionTreeConfig PDA and initializes an empty Merkle tree via CPI to spl-account-compression"
    - "record_contribution instruction appends a contribution leaf to the Merkle tree via CPI and emits full data via noop for indexing"
    - "update_score instruction reallocates DeveloperProfile from 89 to 130 bytes on first call and updates contribution score fields"
    - "Only the designated contribution authority can call record_contribution"
    - "Bankrun tests verify all three instructions execute successfully"
  artifacts:
    - path: "programs/gsd-hub/src/instructions/init_contribution_tree.rs"
      provides: "Merkle tree initialization instruction"
      exports: ["InitContributionTree", "handler"]
    - path: "programs/gsd-hub/src/instructions/record_contribution.rs"
      provides: "Contribution recording with CPI to compression + noop"
      exports: ["RecordContribution", "handler"]
    - path: "programs/gsd-hub/src/instructions/update_score.rs"
      provides: "Score update with PDA realloc"
      exports: ["UpdateContributionScore", "handler"]
    - path: "programs/gsd-hub/tests/contribution.test.ts"
      provides: "Bankrun test suite for all contribution instructions"
  key_links:
    - from: "programs/gsd-hub/src/instructions/record_contribution.rs"
      to: "programs/gsd-hub/src/cpi/compression.rs"
      via: "cpi::compression::append_leaf call"
      pattern: "append_leaf"
    - from: "programs/gsd-hub/src/instructions/record_contribution.rs"
      to: "programs/gsd-hub/src/cpi/noop.rs"
      via: "cpi::noop::wrap_application_data call"
      pattern: "wrap_application_data"
    - from: "programs/gsd-hub/src/instructions/update_score.rs"
      to: "programs/gsd-hub/src/state/developer.rs"
      via: "realloc constraint expanding DeveloperProfile"
      pattern: "realloc = 8 \\+ 130"
    - from: "programs/gsd-hub/src/lib.rs"
      to: "programs/gsd-hub/src/instructions/*"
      via: "instruction entry points in #[program] block"
      pattern: "init_contribution_tree|record_contribution|update_contribution_score"
---

<objective>
Build the three on-chain instructions that form the contribution tracking program logic: tree initialization, contribution recording, and score updates.

Purpose: These instructions are the on-chain API for the contribution system. init_contribution_tree sets up the Merkle tree infrastructure. record_contribution appends verified contributions to the tree and emits data for indexers. update_score writes calculated scores to the developer's PDA with automatic realloc for Phase 1 accounts.

Output: Three new Anchor instructions with bankrun tests, plus updated IDL.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-contribution-tracking/02-RESEARCH.md
@.planning/phases/02-contribution-tracking/02-01-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md

Key existing files:
@programs/gsd-hub/src/lib.rs
@programs/gsd-hub/src/state/developer.rs
@programs/gsd-hub/src/state/contribution.rs (from Plan 01)
@programs/gsd-hub/src/state/merkle_tree.rs (from Plan 01)
@programs/gsd-hub/src/cpi/compression.rs (from Plan 01)
@programs/gsd-hub/src/cpi/noop.rs (from Plan 01)
@programs/gsd-hub/src/errors.rs
@programs/gsd-hub/src/instructions/register.rs
@programs/gsd-hub/src/instructions/update_hash.rs
@programs/gsd-hub/tests/register.test.ts
@Anchor.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement init_contribution_tree, record_contribution, and update_score instructions</name>
  <files>
    programs/gsd-hub/src/instructions/init_contribution_tree.rs
    programs/gsd-hub/src/instructions/record_contribution.rs
    programs/gsd-hub/src/instructions/update_score.rs
    programs/gsd-hub/src/instructions/mod.rs
    programs/gsd-hub/src/lib.rs
  </files>
  <action>
    **1. Create `programs/gsd-hub/src/instructions/init_contribution_tree.rs`:**

    Accounts struct `InitContributionTree`:
    - `tree_config: Account<ContributionTreeConfig>` -- init PDA with seeds `[b"contribution_tree", merkle_tree.key().as_ref()]`, payer = authority
    - `merkle_tree: AccountInfo` (UncheckedAccount, writable) -- the Merkle tree account (pre-allocated by the TypeScript client via `createAllocTreeIx`)
    - `authority: Signer` (mut) -- pays for tree_config PDA, becomes tree authority
    - `compression_program: AccountInfo` -- spl-account-compression program (validate address = ACCOUNT_COMPRESSION_PROGRAM_ID)
    - `noop_program: AccountInfo` -- spl-noop program (validate address = NOOP_PROGRAM_ID)
    - `system_program: Program<System>`

    Handler:
    - Validate compression_program.key == ACCOUNT_COMPRESSION_PROGRAM_ID
    - Validate noop_program.key == NOOP_PROGRAM_ID
    - Call `cpi::compression::init_empty_merkle_tree()` with max_depth=16, max_buffer_size=64
    - Populate tree_config: authority, merkle_tree address, total_contributions=0, bump, created_at from Clock

    Handler args: `max_depth: u32, max_buffer_size: u32` (passed through to init CPI, not hardcoded, for flexibility)

    **2. Create `programs/gsd-hub/src/instructions/record_contribution.rs`:**

    Accounts struct `RecordContribution`:
    - `tree_config: Account<ContributionTreeConfig>` -- seeds `[b"contribution_tree", merkle_tree.key().as_ref()]`, mutable (increment total_contributions)
    - `merkle_tree: AccountInfo` (UncheckedAccount, writable) -- the Merkle tree account
    - `authority: Signer` -- must match tree_config.authority (the contribution authority). This is the designated recorder, NOT the developer whose contribution is being recorded.
    - `noop_program: AccountInfo` -- validate address = NOOP_PROGRAM_ID
    - `compression_program: AccountInfo` -- validate address = ACCOUNT_COMPRESSION_PROGRAM_ID

    Handler args:
    - `developer: Pubkey` -- the developer wallet being credited
    - `task_ref: [u8; 32]` -- task reference hash
    - `verification_score: u16` -- 0-10000
    - `content_hash: [u8; 32]` -- SHA-256 of off-chain content

    Handler logic:
    1. Validate `authority.key() == tree_config.authority` (return InvalidTreeAuthority if not)
    2. Validate `verification_score <= 10000` (return InvalidVerificationScore if not)
    3. Get current timestamp from `Clock::get()?`
    4. Construct `ContributionLeaf { developer, task_ref, verification_score, timestamp, content_hash }`
    5. Compute leaf hash via `contribution.to_leaf_hash()`
    6. Serialize full contribution data via `contribution.try_to_vec()?`
    7. Call `cpi::noop::wrap_application_data()` with the serialized data (106 bytes) -- this emits to logs for the off-chain indexer
    8. Call `cpi::compression::append_leaf()` with the 32-byte leaf hash and `tree_config` bump seeds for PDA signing if tree_config is authority, OR the authority signer. For the initial implementation, authority is a Signer (keypair), not PDA. Use `None` for signer_seeds.
    9. Increment `tree_config.total_contributions += 1`

    **Design decision on authority model (per Research Open Question 5):** Use a designated authority keypair for Phase 2. The authority is whoever initialized the tree (the `authority` field in `ContributionTreeConfig`). Only this account can record contributions. This prevents gaming while keeping the implementation simple. In Phase 5, this can be evolved to an AI verification oracle.

    **3. Create `programs/gsd-hub/src/instructions/update_score.rs`:**

    Accounts struct `UpdateContributionScore`:
    - `developer_profile: Account<DeveloperProfile>` with constraints:
      - `seeds = [b"developer", developer_wallet.key().as_ref()]`
      - `bump = developer_profile.bump`
      - `realloc = 8 + 130` (discriminator + new struct size)
      - `realloc::payer = payer`
      - `realloc::zero = false`
    - `developer_wallet: AccountInfo` (UncheckedAccount) -- the developer whose score is being updated (needed for PDA seeds, does NOT need to sign)
    - `authority: Signer` -- the contribution authority (same as tree authority)
    - `payer: Signer` (mut) -- pays for realloc rent difference
    - `system_program: Program<System>`

    Handler args:
    - `tasks_completed: u32`
    - `total_verification_score: u64`
    - `time_active_days: u32`
    - `contribution_score: u64` -- pre-calculated off-chain, stored as-is
    - `score_version: u8`

    Handler logic:
    1. Update developer_profile fields: tasks_completed, total_verification_score, time_active_days, contribution_score, score_version
    2. Update last_contribution_at from Clock
    3. If first_contribution_at == 0, set it from Clock (first ever score update)
    4. Update updated_at from Clock

    NOTE: The score is calculated off-chain and passed in. On-chain validation of the score is not performed in Phase 2 (it would require duplicating the sqrt calculation on-chain with fixed-point math). The authority model (only designated authority can call this) provides trust. Phase 5 adds AI verification for additional validation.

    **4. Update `programs/gsd-hub/src/instructions/mod.rs`:**

    Add:
    ```rust
    pub mod init_contribution_tree;
    pub mod record_contribution;
    pub mod update_score;

    pub use init_contribution_tree::*;
    pub use record_contribution::*;
    pub use update_score::*;
    ```

    **5. Update `programs/gsd-hub/src/lib.rs`:**

    Add three new instruction entry points in the `#[program]` block:

    ```rust
    pub fn init_contribution_tree(
        ctx: Context<InitContributionTree>,
        max_depth: u32,
        max_buffer_size: u32,
    ) -> Result<()> {
        instructions::init_contribution_tree::handler(ctx, max_depth, max_buffer_size)
    }

    pub fn record_contribution(
        ctx: Context<RecordContribution>,
        developer: Pubkey,
        task_ref: [u8; 32],
        verification_score: u16,
        content_hash: [u8; 32],
    ) -> Result<()> {
        instructions::record_contribution::handler(ctx, developer, task_ref, verification_score, content_hash)
    }

    pub fn update_contribution_score(
        ctx: Context<UpdateContributionScore>,
        tasks_completed: u32,
        total_verification_score: u64,
        time_active_days: u32,
        contribution_score: u64,
        score_version: u8,
    ) -> Result<()> {
        instructions::update_score::handler(ctx, tasks_completed, total_verification_score, time_active_days, contribution_score, score_version)
    }
    ```
  </action>
  <verify>
    Run `anchor build` from the project root. Must compile without errors. Verify:
    - `grep -c "init_contribution_tree" programs/gsd-hub/src/lib.rs` returns >= 1
    - `grep -c "record_contribution" programs/gsd-hub/src/lib.rs` returns >= 1
    - `grep -c "update_contribution_score" programs/gsd-hub/src/lib.rs` returns >= 1
    - Generated IDL at `target/idl/gsd_hub.json` includes all 5 instructions (2 from Phase 1 + 3 new)
    - Check IDL: `node -e "const idl=require('./target/idl/gsd_hub.json'); console.log(idl.instructions.map(i=>i.name))"`
  </verify>
  <done>
    Three new instructions compile: init_contribution_tree (creates tree config PDA + CPI init), record_contribution (appends leaf via CPI + noop logging), update_contribution_score (PDA realloc + score fields). Generated IDL includes all 5 instructions. Program builds cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write bankrun tests for contribution instructions</name>
  <files>
    programs/gsd-hub/tests/contribution.test.ts
  </files>
  <action>
    Create `programs/gsd-hub/tests/contribution.test.ts` following the existing test pattern from `register.test.ts`:
    - Use `startAnchor` + `BankrunProvider` + `Program<GsdHub>` with IDL JSON
    - Import from `@solana/spl-account-compression` for `getConcurrentMerkleTreeAccountSize` and `createAllocTreeIx`

    **IMPORTANT:** Before writing tests, install `@solana/spl-account-compression@0.4.1` as a devDependency in the ROOT package.json (where tests run), NOT in programs/gsd-hub/Cargo.toml:
    ```bash
    pnpm add -D -w @solana/spl-account-compression@0.4.1
    ```

    **Test setup (before each / before all):**
    1. Start anchor with `startAnchor`
    2. Create a BankrunProvider and Program instance
    3. Generate a tree keypair
    4. Calculate tree space via `getConcurrentMerkleTreeAccountSize(16, 64, 10)` -- note: use smaller values for tests if 16/64/10 is too expensive in bankrun. Try depth=3, buffer=8, canopy=0 for fast tests.
    5. Allocate the tree account (SystemProgram.createAccount with enough lamports for rent + space)

    **CRITICAL bankrun limitation:** The SPL Account Compression and Noop programs are NOT loaded by default in bankrun. They must be loaded as extra programs. Check if `startAnchor` supports adding programs from .so files, or if you need to specify them in Anchor.toml under `[programs.localnet]`. The programs need to be available at their known addresses:
    - `cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK` (spl-account-compression)
    - `noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV` (spl-noop)

    If bankrun cannot load these programs, the tests should be structured to run on localnet instead. In that case, update the test file to use `anchor.Provider.local()` and document that `anchor localnet` (or `solana-test-validator`) must be running with the programs deployed. The SPL programs should be available on the test validator by default.

    Alternatively, if `.so` files are available (download from mainnet via `solana program dump`), load them in bankrun via:
    ```typescript
    const context = await startAnchor("", [
      { name: "spl_account_compression", programId: new PublicKey("cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK") },
      { name: "spl_noop", programId: new PublicKey("noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV") },
    ], []);
    ```
    Download the .so files first:
    ```bash
    solana program dump cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK tests/fixtures/spl_account_compression.so --url mainnet-beta
    solana program dump noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV tests/fixtures/spl_noop.so --url mainnet-beta
    ```

    **Test cases:**

    1. **"initializes contribution tree":**
       - Call `init_contribution_tree` with depth=3, buffer_size=8 (small for testing)
       - Assert tree_config PDA was created
       - Assert tree_config.authority == authority pubkey
       - Assert tree_config.merkle_tree == tree account pubkey
       - Assert tree_config.total_contributions == 0

    2. **"records a contribution":**
       - First register a developer profile (call `register_developer` for the test wallet)
       - Call `record_contribution` with test data: developer=test_wallet, task_ref=sha256("test-task-1"), verification_score=8500, content_hash=sha256("test content")
       - Assert tree_config.total_contributions == 1
       - (Cannot easily assert leaf content from bankrun, but the transaction should succeed)

    3. **"rejects contribution with invalid verification score":**
       - Call `record_contribution` with verification_score=15000 (> 10000)
       - Assert it returns InvalidVerificationScore error

    4. **"rejects contribution from non-authority":**
       - Generate a different keypair (not the tree authority)
       - Call `record_contribution` signed by the wrong keypair
       - Assert it returns InvalidTreeAuthority error

    5. **"updates developer contribution score":**
       - Call `update_contribution_score` with tasks_completed=1, total_verification_score=8500, time_active_days=1, contribution_score=92195445n (pre-calculated), score_version=1
       - Fetch the developer_profile PDA
       - Assert tasks_completed == 1
       - Assert contribution_score == 92195445
       - Assert score_version == 1
       - Assert first_contribution_at > 0

    6. **"existing Phase 1 tests still pass":**
       - Run existing register.test.ts to verify no regression

    Use `ts-mocha` as the test runner (matching existing pattern from register.test.ts).
  </action>
  <verify>
    Run all Anchor tests:
    - `anchor test` (runs all tests including existing register tests)
    - OR `npx ts-mocha -p ./tsconfig.json -t 30000 programs/gsd-hub/tests/contribution.test.ts`
    - All contribution tests pass
    - Existing register tests still pass (no regression)
  </verify>
  <done>
    Bankrun tests verify: tree initialization creates config PDA, contribution recording appends leaf and increments count, invalid score is rejected, non-authority is rejected, score update writes fields to PDA with realloc from 89 to 130 bytes. Existing Phase 1 tests pass without changes.
  </done>
</task>

</tasks>

<verification>
1. `anchor build` succeeds -- program compiles with all 5 instructions
2. `anchor test` passes -- all contribution tests + existing register tests pass
3. Generated IDL includes: register_developer, update_profile_hash, init_contribution_tree, record_contribution, update_contribution_score
4. Tree config PDA derivation is deterministic from tree address
5. Score update realloc correctly expands Phase 1 accounts from 89 to 130 bytes
</verification>

<success_criteria>
- All three new instructions compile and are included in the generated IDL
- init_contribution_tree creates tree config PDA and initializes Merkle tree via CPI
- record_contribution validates authority and score, appends leaf, emits noop data
- update_contribution_score reallocates PDA and stores score fields
- All bankrun tests pass including both new contribution tests and existing registration tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-contribution-tracking/02-03-SUMMARY.md`
</output>
