---
phase: 06-advanced-governance
plan: 03
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - packages/utils/src/decay.ts
  - packages/utils/src/decay.test.ts
  - packages/utils/src/score.ts
  - packages/utils/src/index.ts
autonomous: true

must_haves:
  truths:
    - "decayMultiplier returns 1.0 for age 0, 0.5 for age equal to half-life, and approaches 0 for very old contributions"
    - "calculateDecayedScore sums each contribution's verification score weighted by its age-based decay multiplier"
    - "calculateContributionScoreWithDecay produces a lower score than calculateContributionScore for the same inputs when contributions are old"
    - "All decay functions are deterministic: same inputs always produce same output"
    - "DECAY_HALF_LIFE_DAYS defaults to 180 but is configurable as a parameter"
  artifacts:
    - path: "packages/utils/src/decay.ts"
      provides: "Reputation decay computation functions"
      exports: ["decayMultiplier", "calculateDecayedScore", "DECAY_HALF_LIFE_DAYS"]
    - path: "packages/utils/src/decay.test.ts"
      provides: "TDD test suite for decay functions"
      min_lines: 40
  key_links:
    - from: "packages/utils/src/decay.ts"
      to: "packages/utils/src/score.ts"
      via: "Shared contribution score computation with decay"
      pattern: "calculateContributionScore"
---

<objective>
Implement the reputation decay computation as a shared utility with TDD methodology. The decay formula uses exponential half-life: each contribution's verification score is multiplied by `2^(-age/halfLife)`, producing a decayed total that feeds into the existing contribution score formula.

Purpose: Incentivize sustained participation by making old contributions count less over time. This affects revenue share proportions, so correctness is critical -- TDD ensures the math is right.
Output: decay.ts utility with decayMultiplier, calculateDecayedScore, and calculateContributionScoreWithDecay functions, plus comprehensive test suite.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-advanced-governance/06-RESEARCH.md
@.planning/phases/06-advanced-governance/06-01-SUMMARY.md

# Key source files
@packages/utils/src/score.ts
@packages/utils/src/index.ts
</context>

<feature>
  <name>Reputation Decay Computation</name>
  <files>packages/utils/src/decay.ts, packages/utils/src/decay.test.ts</files>
  <behavior>
**decayMultiplier(ageDays, halfLifeDays?)**
- Input: age in days (number), optional half-life (default 180)
- Output: multiplier between 0 and 1 (number)
- Cases:
  - decayMultiplier(0, 180) -> 1.0
  - decayMultiplier(180, 180) -> 0.5
  - decayMultiplier(360, 180) -> 0.25
  - decayMultiplier(540, 180) -> 0.125
  - decayMultiplier(-10, 180) -> 1.0 (negative age treated as 0)
  - decayMultiplier(0, 0) -> 1.0 (edge case: zero half-life)

**calculateDecayedScore(contributions, halfLifeDays?)**
- Input: array of { verificationScore: number, ageDays: number }, optional half-life
- Output: BigInt (decayed total verification score)
- Cases:
  - [] -> 0n (empty array)
  - [{ verificationScore: 10000, ageDays: 0 }] -> 10000n (no decay)
  - [{ verificationScore: 10000, ageDays: 180 }] -> 5000n (half-life)
  - [{ vs: 10000, age: 0 }, { vs: 10000, age: 180 }] -> 15000n (10000 + 5000)
  - [{ vs: 10000, age: 360 }] -> 2500n (two half-lives)

**calculateContributionScoreWithDecay(input)**
- Input: ScoreInput (from score.ts) + contributions array for decay
- Output: BigInt contribution score using decayed verification total
- Must produce LOWER score than calculateContributionScore when contributions are old
  </behavior>
  <implementation>
1. Create decay.ts with:
   - DECAY_HALF_LIFE_DAYS constant = 180
   - decayMultiplier: `Math.pow(2, -ageDays / halfLifeDays)` with edge case handling
   - calculateDecayedScore: iterate contributions, apply decayMultiplier to each verificationScore, sum, round to BigInt
   - calculateContributionScoreWithDecay: wrapper that takes ScoreInput + contributions, computes decayed total, calls calculateContributionScore from score.ts with the decayed total

2. Use node:test runner (existing pattern from 02-02)

3. Export from index.ts barrel
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1 (RED): Write failing tests for decay functions</name>
  <files>
    packages/utils/src/decay.test.ts
    packages/utils/src/decay.ts
  </files>
  <action>
Create `decay.test.ts` using the `node:test` runner (matching the existing pattern from 02-02 in `packages/utils/src/score.test.ts`).

Write comprehensive tests covering all behaviors from the `<feature>` section above:

**decayMultiplier tests:**
- `decayMultiplier(0, 180)` returns 1.0
- `decayMultiplier(180, 180)` returns 0.5
- `decayMultiplier(360, 180)` returns 0.25
- `decayMultiplier(540, 180)` returns 0.125
- `decayMultiplier(-10, 180)` returns 1.0 (negative age clamped)
- `decayMultiplier(0, 0)` returns 1.0 (zero half-life edge case)
- Determinism: same inputs always produce same output (call twice, compare)

**calculateDecayedScore tests:**
- Empty array returns 0n
- Single contribution at age 0 returns full verificationScore as BigInt
- Single contribution at age = halfLife returns half verificationScore
- Multiple contributions with mixed ages returns correct weighted sum
- Two half-lives (age 360, halfLife 180) returns 25% of score

**calculateContributionScoreWithDecay tests:**
- Returns LOWER score than calculateContributionScore when contributions are aged
- Returns EQUAL score when all contributions are age 0
- Accepts configurable halfLifeDays parameter

Create a minimal `decay.ts` stub file that exports the function signatures with `throw new Error("Not implemented")` bodies, so the test file can import them. This ensures tests can be discovered and run (they will fail with the thrown errors, confirming RED state).

Run `node --test packages/utils/src/decay.test.ts` -- all tests MUST FAIL. Commit: `test(06-03): add failing tests for reputation decay`
  </action>
  <verify>
Run `node --test packages/utils/src/decay.test.ts` -- every test must report as FAILED (thrown "Not implemented" errors). Zero passing tests.
`grep -c "it\|test(" packages/utils/src/decay.test.ts` should return >= 10 test cases.
  </verify>
  <done>
decay.test.ts has >= 10 test cases covering decayMultiplier, calculateDecayedScore, and calculateContributionScoreWithDecay. All tests fail against stub implementations. RED phase confirmed.
  </done>
</task>

<task type="auto">
  <name>Task 2 (GREEN): Implement decay functions to pass all tests</name>
  <files>
    packages/utils/src/decay.ts
    packages/utils/src/index.ts
  </files>
  <action>
Implement the real logic in `decay.ts`, replacing the stubs:

**DECAY_HALF_LIFE_DAYS** = 180 (exported constant)

**decayMultiplier(ageDays: number, halfLifeDays: number = DECAY_HALF_LIFE_DAYS): number**
- If ageDays <= 0, return 1.0
- If halfLifeDays <= 0, return 1.0
- Return `Math.pow(2, -ageDays / halfLifeDays)`

**calculateDecayedScore(contributions: Array<{ verificationScore: number, ageDays: number }>, halfLifeDays?: number): bigint**
- If empty array, return 0n
- For each contribution: `score += verificationScore * decayMultiplier(ageDays, halfLifeDays)`
- Round the floating-point sum to nearest integer, convert to BigInt

**calculateContributionScoreWithDecay(input: ScoreInput & { contributions: Array<{ verificationScore: number, ageDays: number }> }, halfLifeDays?: number): bigint**
- Compute decayed total via calculateDecayedScore
- Create a modified ScoreInput with verificationScore replaced by the decayed total
- Call calculateContributionScore from score.ts with the modified input
- Return the result

Export all 3 functions + DECAY_HALF_LIFE_DAYS constant from `index.ts` barrel file.

Run `node --test packages/utils/src/decay.test.ts` -- all tests MUST PASS. Commit: `feat(06-03): implement reputation decay`
  </action>
  <verify>
Run `node --test packages/utils/src/decay.test.ts` -- all tests pass (0 failures).
Verify exports: `grep "decay" packages/utils/src/index.ts` shows barrel exports.
Verify determinism: `node -e "const {decayMultiplier} = require('./packages/utils/src/decay'); console.log(decayMultiplier(180, 180))"` outputs 0.5.
  </verify>
  <done>
All decay tests pass. decayMultiplier(180,180) === 0.5 (exact half-life). calculateDecayedScore produces correct weighted sums. calculateContributionScoreWithDecay produces lower scores for aged contributions. Functions exported from @gsd/utils barrel.
  </done>
</task>

</tasks>

<verification>
- All RED tests fail before implementation (Task 1)
- All GREEN tests pass after implementation (Task 2)
- `node --test packages/utils/src/decay.test.ts` passes
- Edge cases covered: empty array, zero age, negative age, zero half-life, multiple half-lives
</verification>

<success_criteria>
- decayMultiplier(180, 180) === 0.5 (exact half-life)
- calculateDecayedScore with mixed-age contributions produces correct weighted sum
- calculateContributionScoreWithDecay < calculateContributionScore for aged contributions
- All tests pass with node:test runner
- Functions exported from @gsd/utils barrel
</success_criteria>

<output>
After completion, create `.planning/phases/06-advanced-governance/06-03-SUMMARY.md`
</output>
