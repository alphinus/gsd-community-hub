---
phase: 06-advanced-governance
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - programs/gsd-hub/src/instructions/cast_vote.rs
  - programs/gsd-hub/src/instructions/delegate_vote.rs
  - programs/gsd-hub/src/instructions/revoke_delegation.rs
  - programs/gsd-hub/src/instructions/update_governance_config.rs
  - programs/gsd-hub/src/instructions/mod.rs
  - programs/gsd-hub/src/lib.rs
  - programs/gsd-hub/tests/quadratic-voting.test.ts
  - programs/gsd-hub/tests/delegation.test.ts
autonomous: true

must_haves:
  truths:
    - "When quadratic voting is enabled and voter has Civic Pass, vote weight is floor(sqrt(deposited_amount)) instead of deposited_amount"
    - "When quadratic voting is enabled and voter lacks Civic Pass, cast_vote rejects with HumanVerificationRequired"
    - "When quadratic voting is disabled, cast_vote uses linear weight (backward compatible)"
    - "A delegator can delegate voting power to a delegate, and cannot vote directly while delegation is active"
    - "A delegate's effective vote weight includes their own deposit plus all active delegations received"
    - "Delegation can be revoked by the delegator at any time"
    - "Admin can enable quadratic voting and set gatekeeper network via update_governance_config"
  artifacts:
    - path: "programs/gsd-hub/src/instructions/cast_vote.rs"
      provides: "Modified cast_vote with quadratic weight, sybil gate, delegation aggregation"
      contains: "isqrt"
    - path: "programs/gsd-hub/src/instructions/delegate_vote.rs"
      provides: "delegate_vote instruction"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/src/instructions/revoke_delegation.rs"
      provides: "revoke_delegation instruction"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/src/instructions/update_governance_config.rs"
      provides: "update_governance_config instruction for admin"
      contains: "quadratic_voting_enabled"
    - path: "programs/gsd-hub/tests/quadratic-voting.test.ts"
      provides: "Bankrun tests for quadratic voting and sybil gate (7+ tests including gateway validation)"
      min_lines: 100
    - path: "programs/gsd-hub/tests/delegation.test.ts"
      provides: "Bankrun tests for delegation lifecycle"
      min_lines: 80
  key_links:
    - from: "programs/gsd-hub/src/instructions/cast_vote.rs"
      to: "programs/gsd-hub/src/state/governance_config.rs"
      via: "quadratic_voting_enabled flag check"
      pattern: "quadratic_voting_enabled"
    - from: "programs/gsd-hub/src/instructions/cast_vote.rs"
      to: "programs/gsd-hub/src/state/delegation_record.rs"
      via: "remaining_accounts iteration for delegated weight"
      pattern: "remaining_accounts"
    - from: "programs/gsd-hub/src/instructions/delegate_vote.rs"
      to: "programs/gsd-hub/src/state/delegation_record.rs"
      via: "DelegationRecord init"
      pattern: "DelegationRecord"
---

<objective>
Implement the on-chain instructions for quadratic voting with sybil resistance, vote delegation, and governance config updates -- the core smart contract logic for Phase 6.

Purpose: This is the on-chain engine that transforms governance from linear to quadratic voting with delegation support. All instructions must be thoroughly tested with bankrun.
Output: Modified cast_vote, 3 new instructions (delegate_vote, revoke_delegation, update_governance_config), and comprehensive bankrun test suites.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-advanced-governance/06-RESEARCH.md
@.planning/phases/06-advanced-governance/06-01-SUMMARY.md
@.planning/phases/03-governance-idea-rounds/03-04-SUMMARY.md

# Key source files
@programs/gsd-hub/src/instructions/cast_vote.rs
@programs/gsd-hub/src/instructions/deposit_tokens.rs
@programs/gsd-hub/src/instructions/mod.rs
@programs/gsd-hub/src/lib.rs
@programs/gsd-hub/src/state/governance_config.rs
@programs/gsd-hub/src/state/delegation_record.rs
@programs/gsd-hub/src/state/vote_deposit.rs
@programs/gsd-hub/src/errors.rs
@programs/gsd-hub/tests/governance-voting.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement quadratic voting, sybil gate, delegation aggregation in cast_vote plus delegate_vote, revoke_delegation, and update_governance_config instructions</name>
  <files>
    programs/gsd-hub/src/instructions/cast_vote.rs
    programs/gsd-hub/src/instructions/delegate_vote.rs
    programs/gsd-hub/src/instructions/revoke_delegation.rs
    programs/gsd-hub/src/instructions/update_governance_config.rs
    programs/gsd-hub/src/instructions/mod.rs
    programs/gsd-hub/src/lib.rs
  </files>
  <action>
**cast_vote.rs** -- Major modification:

1. Add `isqrt` function (Newton's method integer sqrt for u64) as a module-level helper:
```rust
pub fn isqrt(n: u64) -> u64 {
    if n == 0 { return 0; }
    if n == 1 { return 1; }
    let mut x = n;
    let mut y = (x + 1) / 2;
    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }
    x
}
```

2. Add accounts to CastVote struct:
- `pub governance_config: Account<'info, GovernanceConfig>` -- read-only, seeds = [b"governance_config"], bump = governance_config.bump
- Conditionally require gateway_token when quadratic voting is enabled. Use `/// CHECK: Validated manually below -- gateway token fields deserialized and verified` with `UncheckedAccount` for the gateway token. Implement MANUAL gateway token validation as the PRIMARY approach (no dependency on `solana_gateway` crate, avoids Anchor 0.32.1 compatibility uncertainty):
  - Pass gateway_token as `Option<UncheckedAccount<'info>>`
  - If quadratic_voting_enabled: require gateway_token is Some, then perform these SPECIFIC validation checks:

  **Gateway Token Manual Validation (ADVG-01 Sybil Resistance):**

  The Civic Gateway Token account layout is: `version[1] | owner_pubkey[32] | gatekeeper_network[32] | state[8] | expiry[8] | ...`
  Total minimum size: 81 bytes (version + owner + network + state + expiry).

  Validation steps (all required):
  1. **Program owner check**: `gateway_token.owner == &civic_gateway_program_id` where Civic Gateway Program = `gatem74V238djXdzWnJf2FWTnQ8pUV3yHZ7BLKhys`. Reject with `GovernanceError::InvalidGatewayToken` if wrong owner.
  2. **Data length check**: `gateway_token.data_len() >= 81`. Reject with `GovernanceError::InvalidGatewayToken` if too short.
  3. **Subject/owner match**: Read bytes `[1..33]` as Pubkey (the token subject). Verify it matches `voter.key()`. Reject with `GovernanceError::GatewayTokenOwnerMismatch` -- prevents using someone else's Civic Pass.
  4. **Gatekeeper network match**: Read bytes `[33..65]` as Pubkey. Verify it matches `governance_config.civic_gatekeeper_network`. Reject with `GovernanceError::GatewayNetworkMismatch` -- ensures the correct identity verification level.
  5. **Active state check**: Read bytes `[65..73]` as little-endian u64. Value `0` = Active. Reject with `GovernanceError::GatewayTokenNotActive` if state != 0 (covers Revoked, Frozen states).
  6. **Expiry check**: Read bytes `[73..81]` as little-endian u64 Unix timestamp. If non-zero and `< Clock::get()?.unix_timestamp`, reject with `GovernanceError::GatewayTokenExpired`.

  **Implementation pattern:**
  ```rust
  if ctx.accounts.governance_config.quadratic_voting_enabled {
      let gt_info = ctx.accounts.gateway_token.as_ref()
          .ok_or(GovernanceError::HumanVerificationRequired)?;
      let civic_gateway = Pubkey::from_str("gatem74V238djXdzWnJf2FWTnQ8pUV3yHZ7BLKhys").unwrap();
      require!(gt_info.owner == &civic_gateway, GovernanceError::InvalidGatewayToken);
      let gt_data = gt_info.try_borrow_data()?;
      require!(gt_data.len() >= 81, GovernanceError::InvalidGatewayToken);
      let subject = Pubkey::try_from(&gt_data[1..33]).unwrap();
      let network = Pubkey::try_from(&gt_data[33..65]).unwrap();
      let state = u64::from_le_bytes(gt_data[65..73].try_into().unwrap());
      let expiry = u64::from_le_bytes(gt_data[73..81].try_into().unwrap());
      require!(subject == ctx.accounts.voter.key(), GovernanceError::GatewayTokenOwnerMismatch);
      require!(network == ctx.accounts.governance_config.civic_gatekeeper_network, GovernanceError::GatewayNetworkMismatch);
      require!(state == 0, GovernanceError::GatewayTokenNotActive);
      let clock = Clock::get()?;
      if expiry > 0 {
          require!(expiry as i64 >= clock.unix_timestamp, GovernanceError::GatewayTokenExpired);
      }
  }
  ```

  Add these error variants to `errors.rs` (in addition to HumanVerificationRequired):
  - `GatewayTokenOwnerMismatch` -- "Gateway token subject does not match voter"
  - `GatewayNetworkMismatch` -- "Gateway token network does not match configured gatekeeper"
  - `GatewayTokenNotActive` -- "Gateway token is not in Active state"
  - `GatewayTokenExpired` -- "Gateway token has expired"

  This manual deserialization achieves full sybil resistance verification (ADVG-01) with zero external crate dependencies. The byte offsets are derived from the stable Civic Gateway Token account layout.

3. Add DelegationRecord check: Before calculating weight, check if voter has an active delegation. Seeds: ["delegation", voter.key()]. If DelegationRecord exists and is_active = true, reject with `GovernanceError::VotingPowerDelegated` (prevents double-counting).

4. Modify weight calculation:
```rust
// Base weight from voter's own deposit
let mut total_tokens: u64 = ctx.accounts.vote_deposit.deposited_amount;

// Add delegated tokens from remaining_accounts
for account_info in ctx.remaining_accounts.iter() {
    let delegation = Account::<DelegationRecord>::try_from(account_info)?;
    require!(delegation.delegate == ctx.accounts.voter.key(), GovernanceError::InvalidDelegation);
    require!(delegation.is_active, GovernanceError::DelegationInactive);
    // Only count delegations effective for current round or earlier
    total_tokens = total_tokens.checked_add(delegation.delegated_amount).ok_or(GovernanceError::Overflow)?;
}

// Apply quadratic or linear formula
let weight = if ctx.accounts.governance_config.quadratic_voting_enabled {
    isqrt(total_tokens)
} else {
    total_tokens
};
```

**delegate_vote.rs** -- Create NEW instruction:
- Accounts: governance_config (read), vote_deposit (read, must have deposited_amount > 0, active_votes == 0), delegation_record (init, seeds ["delegation", delegator.key()]), delegator (signer), delegate (UncheckedAccount -- just stored), system_program
- Handler: Set all DelegationRecord fields. delegated_amount = vote_deposit.deposited_amount. effective_from_round = governance_config.round_count (takes effect next round). delegated_at = Clock::get().unix_timestamp. is_active = true.

**revoke_delegation.rs** -- Create NEW instruction:
- Accounts: delegation_record (mut, seeds ["delegation", delegator.key()], constraint is_active = true), delegator (signer)
- Handler: Set is_active = false. Optionally close account and return rent to delegator (use close = delegator constraint on the account for rent reclaim).
- Actually, don't close -- set is_active = false so delegation can be re-created (PDA will conflict with init if closed and re-inited in same slot). Instead, just set is_active = false and the delegator can create a new delegation later by closing and reiniting. Better approach: close the account so a new delegation can be created. Use `delegation_record.close(delegator.to_account_info())` at end of handler.

**update_governance_config.rs** -- Create NEW instruction:
- Accounts: governance_config (mut, seeds, admin signer constraint), admin (signer)
- Args: quadratic_voting_enabled (bool), civic_gatekeeper_network (Pubkey), decay_half_life_days (u16)
- Handler: Realloc governance_config to new size (168 bytes) if needed. Set the 3 new fields.
- NOTE: Since GovernanceConfig is being extended with 35 new bytes (133 -> 168), the existing init instruction created it at 133 bytes. This instruction must realloc. Use `#[account(mut, realloc = 8 + 168, realloc::payer = admin, realloc::zero = false)]` on governance_config.

**mod.rs** -- Add module declarations and pub use for delegate_vote, revoke_delegation, update_governance_config.

**lib.rs** -- Add 3 new instruction handlers:
- `pub fn delegate_vote(ctx: Context<DelegateVote>) -> Result<()>`
- `pub fn revoke_delegation(ctx: Context<RevokeDelegation>) -> Result<()>`
- `pub fn update_governance_config(ctx: Context<UpdateGovernanceConfig>, quadratic_voting_enabled: bool, civic_gatekeeper_network: Pubkey, decay_half_life_days: u16) -> Result<()>`

Run `anchor build` to verify compilation.
  </action>
  <verify>
Run `anchor build` -- must compile with no errors.
Verify isqrt function: `grep "pub fn isqrt" programs/gsd-hub/src/instructions/cast_vote.rs`
Verify new instructions exist: `grep "delegate_vote\|revoke_delegation\|update_governance_config" programs/gsd-hub/src/lib.rs`
Verify governance_config realloc: `grep "realloc" programs/gsd-hub/src/instructions/update_governance_config.rs`
  </verify>
  <done>
cast_vote supports quadratic weight (isqrt) with sybil gate and delegation aggregation via remaining_accounts. delegate_vote creates DelegationRecord PDA. revoke_delegation closes DelegationRecord. update_governance_config reallocs and sets quadratic/Civic/decay fields. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bankrun tests for quadratic voting, sybil gate, and delegation lifecycle</name>
  <files>
    programs/gsd-hub/tests/quadratic-voting.test.ts
    programs/gsd-hub/tests/delegation.test.ts
  </files>
  <action>
**quadratic-voting.test.ts** -- Create bankrun test suite:

Test setup: Initialize governance config, create a round, create mint, deposit tokens for voters. Then call update_governance_config to enable quadratic voting (set quadratic_voting_enabled = true, civic_gatekeeper_network to a test pubkey, decay_half_life_days = 180).

Tests (minimum 7):
1. **"linear voting weight when quadratic disabled"** -- With quadratic_voting_enabled=false, cast_vote should use full deposited_amount as weight (regression test)
2. **"quadratic voting weight is sqrt of deposited tokens"** -- Enable quadratic, deposit 10000 tokens, cast_vote should record weight = isqrt(10000) = 100. Create a mock gateway token account: allocate >= 81 bytes, set owner to Civic Gateway program (`gatem74V238djXdzWnJf2FWTnQ8pUV3yHZ7BLKhys`), write version byte + voter pubkey at [1..33] + gatekeeper_network at [33..65] + state=0 at [65..73] + expiry=0 at [73..81]. Pass this as the gateway_token optional account.
3. **"quadratic voting rejects without gateway token"** -- Enable quadratic, attempt cast_vote without gateway_token account. Should fail with HumanVerificationRequired.
4. **"quadratic voting rejects wrong gateway token owner"** -- Create gateway token with wrong subject pubkey (not voter). Should fail with GatewayTokenOwnerMismatch.
5. **"quadratic voting rejects expired gateway token"** -- Create gateway token with expiry timestamp in the past. Should fail with GatewayTokenExpired.
6. **"update_governance_config sets new fields"** -- Call update_governance_config, read back governance_config account, verify all 3 fields set correctly
7. **"update_governance_config rejects non-admin"** -- Non-admin signer should fail

**delegation.test.ts** -- Create bankrun test suite:

Test setup: Same governance + round + mint setup.

Tests (minimum 6):
1. **"delegate voting power to another wallet"** -- delegator deposits tokens, calls delegate_vote, verify DelegationRecord created with correct fields
2. **"delegator cannot vote while delegation active"** -- After delegating, delegator's cast_vote should fail with VotingPowerDelegated
3. **"delegate votes with combined weight"** -- Delegate deposits own tokens + receives delegation. cast_vote passes DelegationRecord as remaining_account. Weight should be isqrt(own_deposit + delegated_amount) when quadratic enabled, or (own_deposit + delegated_amount) when linear.
4. **"revoke delegation"** -- Delegator calls revoke_delegation. DelegationRecord account should be closed. Delegator can now vote directly again.
5. **"cannot delegate with no deposit"** -- Wallet with 0 deposited tokens should fail delegate_vote
6. **"cannot delegate with active votes"** -- Wallet with active_votes > 0 should fail delegate_vote

Use existing test patterns from governance-voting.test.ts: startAnchor, BankrunProvider, SPL token fixtures, createTokenAccount/mintTo helpers.
  </action>
  <verify>
Run `anchor test` -- all tests must pass including new quadratic-voting and delegation suites.
Count tests: `grep -c "it(" programs/gsd-hub/tests/quadratic-voting.test.ts` should be >= 7
Count tests: `grep -c "it(" programs/gsd-hub/tests/delegation.test.ts` should be >= 6
Verify no regressions: existing governance-voting.test.ts tests still pass.
  </verify>
  <done>
At least 7 quadratic voting tests pass (linear fallback, sqrt weight, sybil rejection, wrong owner rejection, expired token rejection, config update, unauthorized config). At least 6 delegation tests pass (create, delegator blocked, combined weight, revoke, no deposit, active votes). All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
- `anchor build` compiles with all 26+ instructions
- `anchor test` passes all test suites (existing + new)
- isqrt(10000) == 100, isqrt(0) == 0, isqrt(1) == 1 verified in tests
- Delegation lifecycle (create -> block delegator -> aggregate weight -> revoke -> unblock) verified
- Quadratic voting disabled = linear weight (backward compatible)
- Sybil gate rejects voters without gateway token when quadratic enabled
- Sybil gate rejects gateway token with wrong owner, wrong network, or expired timestamp
- Manual gateway token deserialization validates all 6 fields (owner, data length, subject, network, state, expiry)
</verification>

<success_criteria>
- cast_vote supports both linear (v1) and quadratic (v2) voting based on governance_config flag
- Sybil gate prevents voting without gateway token when quadratic is enabled
- Delegation creates/revokes DelegationRecord PDA
- Delegator cannot vote directly while delegation is active
- Delegate accumulates delegated weight via remaining_accounts
- All bankrun tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-advanced-governance/06-02-SUMMARY.md`
</output>
