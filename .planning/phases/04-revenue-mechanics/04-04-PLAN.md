---
phase: 04-revenue-mechanics
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - apps/web/lib/revenue/distributor.ts
  - apps/web/lib/revenue/detection.ts
  - apps/web/app/api/revenue/distribute/route.ts
autonomous: true
user_setup:
  - service: jupiter
    why: "Buy-and-burn swap execution via Jupiter Swap API"
    env_vars:
      - name: JUPITER_API_KEY
        source: "Jupiter Station -> API access (https://station.jup.ag/)"
      - name: BURN_AUTHORITY_KEYPAIR
        source: "Generate a dedicated Solana keypair for burn operations. Store the base58-encoded secret key."
    dashboard_config: []

must_haves:
  truths:
    - "Server-side Jupiter API integration can quote and execute SOL/USDC -> $GSD swaps"
    - "$GSD tokens acquired via Jupiter swap are burned using anchor_spl::token::burn"
    - "Burn is recorded on-chain linking back to the originating revenue event"
    - "Distribution API endpoint triggers the full split + burn pipeline"
    - "Jupiter swap failures don't block treasury/maintenance/developer pool distribution"
  artifacts:
    - path: "apps/web/lib/revenue/distributor.ts"
      provides: "Server-side Jupiter swap + burn execution logic"
      exports: ["executeBuyAndBurn", "distributeRevenue"]
    - path: "apps/web/lib/revenue/detection.ts"
      provides: "Revenue detection logic for SOL/USDC inflows"
      exports: ["detectRevenueInflow"]
    - path: "apps/web/app/api/revenue/distribute/route.ts"
      provides: "POST /api/revenue/distribute endpoint"
      exports: ["POST"]
  key_links:
    - from: "apps/web/lib/revenue/distributor.ts"
      to: "https://api.jup.ag/swap/v1/"
      via: "Jupiter Swap API for buy-and-burn"
      pattern: "api\\.jup\\.ag/swap/v1"
    - from: "apps/web/lib/revenue/distributor.ts"
      to: "programs/gsd-hub/src/instructions/execute_burn.rs"
      via: "Calls execute_burn on-chain instruction after Jupiter swap"
      pattern: "execute_burn|executeBurn"
    - from: "apps/web/lib/revenue/detection.ts"
      to: "apps/web/lib/treasury/client.ts"
      via: "Uses treasury address constants for inflow detection"
      pattern: "TREASURY_ADDRESS"
---

<objective>
Build the server-side revenue distribution pipeline: detect treasury inflows, compute splits, execute Jupiter buy-and-burn, and record burns on-chain.

Purpose: This is the economic engine -- when revenue arrives, it must be automatically split and the 10% burn must execute a real Jupiter swap + SPL token burn.
Output: Revenue detection module, Jupiter buy-and-burn distributor, distribution API endpoint
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-revenue-mechanics/04-RESEARCH.md
@.planning/phases/04-revenue-mechanics/04-01-SUMMARY.md
@.planning/phases/04-revenue-mechanics/04-02-SUMMARY.md

# Treasury client for address constants
@apps/web/lib/treasury/client.ts

# Existing Anchor provider pattern
@apps/web/lib/anchor/provider.ts

# Revenue types and PDA helpers
@packages/types/src/revenue.ts
@packages/utils/src/revenue-pda.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create revenue detection and Jupiter buy-and-burn distributor</name>
  <files>
    apps/web/lib/revenue/detection.ts
    apps/web/lib/revenue/distributor.ts
  </files>
  <action>
**apps/web/lib/revenue/detection.ts** -- Revenue inflow detection logic:
- Import `TREASURY_ADDRESS_STR, GSD_MINT_STR` from `@/lib/treasury/client`
- Import `HeliusEnhancedTransaction` type from contributions indexer
- Export `detectRevenueInflow(transaction: HeliusEnhancedTransaction): { token: 'sol' | 'usdc'; amount: bigint } | null`
- Logic:
  1. Check `nativeTransfers` for SOL inflows to TREASURY_ADDRESS_STR where amount > 0
  2. Check `tokenTransfers` for USDC inflows to TREASURY_ADDRESS_STR (USDC mint: `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` for mainnet, configurable via env)
  3. Sum all matching inflows per token type
  4. Return the largest inflow (SOL or USDC), or null if none detected
  5. Ignore outflows and non-treasury transfers
- Export `USDC_MINT_STR` constant: `process.env.NEXT_PUBLIC_USDC_MINT || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"`

**apps/web/lib/revenue/distributor.ts** -- Server-side distribution pipeline:
- Import `Connection, VersionedTransaction, Keypair, PublicKey` from `@solana/web3.js`

**Constants:**
- `JUPITER_API_BASE = "https://api.jup.ag/swap/v1"`
- `SOL_MINT = "So11111111111111111111111111111111111111112"`
- `USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"`

**Export `executeBuyAndBurn` function:**
```typescript
export async function executeBuyAndBurn(params: {
  connection: Connection;
  burnAuthority: Keypair;
  inputMint: string;     // SOL_MINT or USDC_MINT
  gsdMint: string;
  amountLamports: bigint;
  jupiterApiKey: string;
}): Promise<{ swapSignature: string; gsdBurned: bigint } | null>
```
Implementation:
1. **Quote**: GET `{JUPITER_API_BASE}/quote?inputMint={inputMint}&outputMint={gsdMint}&amount={amountLamports}&slippageBps=150` with `x-api-key` header
2. **Swap**: POST `{JUPITER_API_BASE}/swap` with body `{ quoteResponse, userPublicKey: burnAuthority.publicKey.toBase58(), dynamicComputeUnitLimit: true, dynamicSlippage: true, prioritizationFeeLamports: { priorityLevelWithMaxLamports: { maxLamports: 500000, priorityLevel: "high" } } }` and `x-api-key` header
3. **Sign & send**: Deserialize the base64 `swapTransaction` into `VersionedTransaction`, sign with `burnAuthority`, send with `skipPreflight: true`
4. **Confirm**: `connection.confirmTransaction(swapSignature)`
5. **Return** `{ swapSignature, gsdBurned: BigInt(quoteResponse.outAmount) }`
6. **Error handling**: Wrap each step in try/catch. Log errors. Return `null` on failure (buy-and-burn failure must NOT block other distributions per research pitfall #3).

**Export `distributeRevenue` function:**
```typescript
export async function distributeRevenue(params: {
  totalAmount: bigint;
  token: 'sol' | 'usdc';
  originSignature: string;
  connection: Connection;
  burnAuthority?: Keypair;
  jupiterApiKey?: string;
  gsdMint?: string;
}): Promise<{
  eventIndex: number;
  splits: { developerPool: bigint; treasuryReserve: bigint; burnAmount: bigint; maintenance: bigint };
  burnResult: { swapSignature: string; gsdBurned: bigint } | null;
}>
```
Implementation:
1. Compute splits using 60/20/10/10: `developerPool = totalAmount * 6000n / 10000n`, etc. Assign remainder to developerPool.
2. Record revenue event to database via Prisma (the on-chain record_revenue_event is called separately by the admin)
3. If burnAuthority and jupiterApiKey provided, attempt buy-and-burn for the `burnAmount`. Use `executeBuyAndBurn`. If it fails, log warning and continue -- burn can be retried later.
4. Return the computed splits and burn result (null if skipped/failed).

**Export `loadBurnAuthority` function:**
- Load keypair from `BURN_AUTHORITY_KEYPAIR` env var (base58-encoded secret key) or `BURN_AUTHORITY_KEYPAIR_PATH` (path to JSON file)
- Return `Keypair` or null if not configured
- Log warning if not configured: "BURN_AUTHORITY_KEYPAIR not set -- buy-and-burn disabled"

IMPORTANT: The distributor does NOT automatically trigger on webhook events. In v1, distribution is triggered manually via the API endpoint (plan task 2) by the admin. Automatic triggering can be added in a future iteration. This matches the research recommendation of requiring admin validation for revenue events.
  </action>
  <verify>TypeScript compiles: `cd apps/web && npx tsc --noEmit`. The distributor module exports executeBuyAndBurn and distributeRevenue functions.</verify>
  <done>Revenue detection identifies SOL/USDC inflows to treasury. Buy-and-burn distributor quotes Jupiter, executes swap, and returns result. Distribution pipeline computes splits and handles burn failures gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Create distribution API endpoint</name>
  <files>
    apps/web/app/api/revenue/distribute/route.ts
  </files>
  <action>
**POST /api/revenue/distribute** (`apps/web/app/api/revenue/distribute/route.ts`):

This is an admin-only endpoint that triggers revenue distribution for a detected inflow.

- Import `distributeRevenue, loadBurnAuthority` from `@/lib/revenue/distributor`
- Import `prisma` from `@/lib/db`
- Import `Connection` from `@solana/web3.js`

**Authentication**: Check for admin authorization. For v1, use a simple `REVENUE_ADMIN_SECRET` env var comparison in the Authorization header (same pattern as Helius webhook auth). In production, this would be replaced with wallet-signature auth or multisig approval.

**Request body** (JSON):
```typescript
{
  totalAmount: string;    // BigInt as string
  token: 'sol' | 'usdc';
  originSignature: string; // The originating treasury inflow tx signature
}
```

**Handler logic**:
1. Validate auth: compare `request.headers.get('authorization')` against `process.env.REVENUE_ADMIN_SECRET`. Return 401 if mismatch.
2. Parse and validate body: totalAmount must be positive, token must be 'sol' or 'usdc', originSignature required.
3. Check idempotency: query `prisma.revenueEvent.findUnique({ where: { originSignature } })`. If exists, return 409 with the existing event (prevent double-processing).
4. Get connection from env: `new Connection(process.env.NEXT_PUBLIC_RPC_URL || "https://api.devnet.solana.com")`
5. Load burn authority via `loadBurnAuthority()`.
6. Call `distributeRevenue({ totalAmount: BigInt(body.totalAmount), token: body.token, originSignature: body.originSignature, connection, burnAuthority, jupiterApiKey: process.env.JUPITER_API_KEY, gsdMint: process.env.NEXT_PUBLIC_GSD_MINT })`.
7. Return 200 with distribution result: `{ eventIndex, splits (as strings), burnResult }`.

**Error handling**: Wrap in try/catch, return 500 on unexpected errors. Log all distribution attempts for audit trail.

**Environment variables used**:
- `REVENUE_ADMIN_SECRET` -- auth for the distribute endpoint
- `JUPITER_API_KEY` -- Jupiter Swap API key (optional, burn skipped without it)
- `BURN_AUTHORITY_KEYPAIR` -- base58 secret key for burn operations (optional)
- `NEXT_PUBLIC_RPC_URL` -- Solana RPC endpoint
- `NEXT_PUBLIC_GSD_MINT` -- $GSD token mint address
  </action>
  <verify>TypeScript compiles. POST endpoint exports correctly. Manual test: `curl -X POST http://localhost:3000/api/revenue/distribute -H "Authorization: test-secret" -H "Content-Type: application/json" -d '{"totalAmount":"1000000000","token":"sol","originSignature":"test123"}' ` returns 200 with split data (or 401 if secret mismatch).</verify>
  <done>Distribution API endpoint accepts admin-authenticated POST, computes 60/20/10/10 split, persists to database, attempts Jupiter buy-and-burn, returns distribution result</done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes
2. Revenue detection correctly identifies SOL inflows to treasury address
3. Jupiter quote/swap flow handles API errors gracefully (returns null, not throw)
4. Distribution endpoint requires authentication
5. Idempotency: duplicate originSignature returns 409
6. Splits computed correctly: 10 SOL -> 6/2/1/1
7. Missing burn authority logs warning but doesn't fail distribution
</verification>

<success_criteria>
- Revenue detection identifies SOL and USDC inflows to treasury
- Jupiter Swap API integration quotes and builds swap transactions
- Buy-and-burn failure doesn't block other distributions
- Distribution endpoint is admin-authenticated and idempotent
- All BigInt values handled correctly across API boundary
</success_criteria>

<output>
After completion, create `.planning/phases/04-revenue-mechanics/04-04-SUMMARY.md`
</output>
