---
phase: 04-revenue-mechanics
plan: 04
type: execute
wave: 4
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - apps/web/lib/revenue/distributor.ts
  - apps/web/app/api/revenue/distribute/route.ts
autonomous: true
user_setup:
  - service: jupiter
    why: "Buy-and-burn swap execution via Jupiter Swap API"
    env_vars:
      - name: JUPITER_API_KEY
        source: "Jupiter Station -> API access (https://station.jup.ag/)"
      - name: BURN_AUTHORITY_KEYPAIR
        source: "Generate a dedicated Solana keypair for burn operations. Store the base58-encoded secret key."
    dashboard_config: []

must_haves:
  truths:
    - "Server-side Jupiter API integration can quote and execute SOL/USDC -> $GSD swaps"
    - "$GSD tokens acquired via Jupiter swap are burned using anchor_spl::token::burn"
    - "Burn is recorded on-chain linking back to the originating revenue event"
    - "Distribution API endpoint triggers the full split + burn pipeline"
    - "Jupiter swap failures don't block treasury/maintenance/developer pool distribution"
  artifacts:
    - path: "apps/web/lib/revenue/distributor.ts"
      provides: "Server-side Jupiter swap + burn execution logic"
      exports: ["executeBuyAndBurn", "distributeRevenue"]
    - path: "apps/web/app/api/revenue/distribute/route.ts"
      provides: "POST /api/revenue/distribute endpoint"
      exports: ["POST"]
  key_links:
    - from: "apps/web/lib/revenue/distributor.ts"
      to: "https://api.jup.ag/swap/v1/"
      via: "Jupiter Swap API for buy-and-burn"
      pattern: "api\\.jup\\.ag/swap/v1"
    - from: "apps/web/lib/revenue/distributor.ts"
      to: "programs/gsd-hub/src/instructions/execute_burn.rs"
      via: "Calls execute_burn on-chain instruction after Jupiter swap"
      pattern: "execute_burn|executeBurn"
    - from: "apps/web/lib/revenue/distributor.ts"
      to: "apps/web/lib/revenue/detection.ts"
      via: "Imports detectRevenueInflow from detection module (created in plan 04-03)"
      pattern: "detectRevenueInflow"
---

<objective>
Build the server-side revenue distribution pipeline: detect treasury inflows, compute splits, execute Jupiter buy-and-burn, and record burns on-chain.

Purpose: This is the economic engine -- when revenue arrives, it must be automatically split and the 10% burn must execute a real Jupiter swap + SPL token burn.
Output: Revenue detection module, Jupiter buy-and-burn distributor, distribution API endpoint
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-revenue-mechanics/04-RESEARCH.md
@.planning/phases/04-revenue-mechanics/04-01-SUMMARY.md
@.planning/phases/04-revenue-mechanics/04-02-SUMMARY.md
@.planning/phases/04-revenue-mechanics/04-03-SUMMARY.md

# Detection module (created in plan 04-03)
@apps/web/lib/revenue/detection.ts

# Treasury client for address constants
@apps/web/lib/treasury/client.ts

# Existing Anchor provider pattern
@apps/web/lib/anchor/provider.ts

# Revenue types and PDA helpers
@packages/types/src/revenue.ts
@packages/utils/src/revenue-pda.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create revenue detection and Jupiter buy-and-burn distributor</name>
  <files>
    apps/web/lib/revenue/distributor.ts
  </files>
  <action>
NOTE: `detection.ts` (containing `detectRevenueInflow`) is now created in plan 04-03 and wired into the Helius webhook there. The distributor imports from it.

**apps/web/lib/revenue/distributor.ts** -- Server-side distribution pipeline:
- Import `Connection, VersionedTransaction, Keypair, PublicKey` from `@solana/web3.js`

**Constants:**
- `JUPITER_API_BASE = "https://api.jup.ag/swap/v1"`
- `SOL_MINT = "So11111111111111111111111111111111111111112"`
- `USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"`

**Export `executeBuyAndBurn` function:**
```typescript
export async function executeBuyAndBurn(params: {
  connection: Connection;
  burnAuthority: Keypair;
  inputMint: string;     // SOL_MINT or USDC_MINT
  gsdMint: string;
  amountLamports: bigint;
  jupiterApiKey: string;
}): Promise<{ swapSignature: string; gsdBurned: bigint } | null>
```
Implementation:
1. **Quote**: GET `{JUPITER_API_BASE}/quote?inputMint={inputMint}&outputMint={gsdMint}&amount={amountLamports}&slippageBps=150` with `x-api-key` header
2. **Swap**: POST `{JUPITER_API_BASE}/swap` with body `{ quoteResponse, userPublicKey: burnAuthority.publicKey.toBase58(), dynamicComputeUnitLimit: true, dynamicSlippage: true, prioritizationFeeLamports: { priorityLevelWithMaxLamports: { maxLamports: 500000, priorityLevel: "high" } } }` and `x-api-key` header
3. **Sign & send**: Deserialize the base64 `swapTransaction` into `VersionedTransaction`, sign with `burnAuthority`, send with `skipPreflight: true`
4. **Confirm**: `connection.confirmTransaction(swapSignature)`
5. **Return** `{ swapSignature, gsdBurned: BigInt(quoteResponse.outAmount) }`
6. **Error handling**: Wrap each step in try/catch. Log errors. Return `null` on failure (buy-and-burn failure must NOT block other distributions per research pitfall #3).

**Export `distributeRevenue` function:**
```typescript
export async function distributeRevenue(params: {
  totalAmount: bigint;
  token: 'sol' | 'usdc';
  originSignature: string;
  connection: Connection;
  burnAuthority?: Keypair;
  jupiterApiKey?: string;
  gsdMint?: string;
}): Promise<{
  eventIndex: number;
  splits: { developerPool: bigint; treasuryReserve: bigint; burnAmount: bigint; maintenance: bigint };
  burnResult: { swapSignature: string; gsdBurned: bigint } | null;
}>
```
Implementation:
1. Compute splits using 60/20/10/10: `developerPool = totalAmount * 6000n / 10000n`, etc. Assign remainder to developerPool.
2. Record revenue event to database via Prisma (the on-chain record_revenue_event is called separately by the admin)
3. If burnAuthority and jupiterApiKey provided, attempt buy-and-burn for the `burnAmount`. Use `executeBuyAndBurn`. If it fails, log warning and continue -- burn can be retried later.
4. Return the computed splits and burn result (null if skipped/failed).

**Export `loadBurnAuthority` function:**
- Load keypair from `BURN_AUTHORITY_KEYPAIR` env var (base58-encoded secret key) or `BURN_AUTHORITY_KEYPAIR_PATH` (path to JSON file)
- Return `Keypair` or null if not configured
- Log warning if not configured: "BURN_AUTHORITY_KEYPAIR not set -- buy-and-burn disabled"

IMPORTANT: The distributor does NOT automatically trigger on webhook events. In v1, distribution is triggered manually via the API endpoint (plan task 2) by the admin. Automatic triggering can be added in a future iteration. This matches the research recommendation of requiring admin validation for revenue events.
  </action>
  <verify>TypeScript compiles: `cd apps/web && npx tsc --noEmit`. The distributor module exports executeBuyAndBurn and distributeRevenue functions.</verify>
  <done>Buy-and-burn distributor quotes Jupiter, executes swap, and returns result. Distribution pipeline computes splits and handles burn failures gracefully. Imports detectRevenueInflow from detection.ts (created in plan 04-03).</done>
</task>

<task type="auto">
  <name>Task 2: Create distribution API endpoint</name>
  <files>
    apps/web/app/api/revenue/distribute/route.ts
  </files>
  <action>
**POST /api/revenue/distribute** (`apps/web/app/api/revenue/distribute/route.ts`):

This is an admin-only endpoint that triggers revenue distribution for a detected inflow.

- Import `distributeRevenue, loadBurnAuthority` from `@/lib/revenue/distributor`
- Import `prisma` from `@/lib/db`
- Import `Connection` from `@solana/web3.js`

**Authentication**: Check for admin authorization. For v1, use a simple `REVENUE_ADMIN_SECRET` env var comparison in the Authorization header (same pattern as Helius webhook auth). In production, this would be replaced with wallet-signature auth or multisig approval.

**Request body** (JSON):
```typescript
{
  totalAmount: string;    // BigInt as string (optional if pendingRevenueId provided)
  token: 'sol' | 'usdc'; // (optional if pendingRevenueId provided)
  originSignature: string; // The originating treasury inflow tx signature (optional if pendingRevenueId provided)
  pendingRevenueId?: string; // ID of a PendingRevenue record to process (from webhook detection)
}
```

**Handler logic**:
1. Validate auth: compare `request.headers.get('authorization')` against `process.env.REVENUE_ADMIN_SECRET`. Return 401 if mismatch.
2. Parse and validate body. Two modes:
   - **Direct mode**: totalAmount, token, originSignature provided directly. Validate all present and valid.
   - **PendingRevenue mode**: pendingRevenueId provided. Look up the PendingRevenue record via `prisma.pendingRevenue.findUnique({ where: { id: pendingRevenueId } })`. If not found, return 404. If status is not "pending", return 409 ("already processed"). Extract totalAmount, token, originSignature (transactionSignature) from the record.
3. Check idempotency: query `prisma.revenueEvent.findUnique({ where: { originSignature } })`. If exists, return 409 with the existing event (prevent double-processing).
4. Get connection from env: `new Connection(process.env.NEXT_PUBLIC_RPC_URL || "https://api.devnet.solana.com")`
5. Load burn authority via `loadBurnAuthority()`.
6. Call `distributeRevenue({ totalAmount: BigInt(body.totalAmount), token: body.token, originSignature: body.originSignature, connection, burnAuthority, jupiterApiKey: process.env.JUPITER_API_KEY, gsdMint: process.env.NEXT_PUBLIC_GSD_MINT })`.
7. If pendingRevenueId was provided, update the PendingRevenue record: `prisma.pendingRevenue.update({ where: { id: pendingRevenueId }, data: { status: 'processed', processedEventId: result.eventId, reviewedAt: new Date() } })`.
8. Return 200 with distribution result: `{ eventIndex, splits (as strings), burnResult }`.

**Error handling**: Wrap in try/catch, return 500 on unexpected errors. Log all distribution attempts for audit trail.

**Environment variables used**:
- `REVENUE_ADMIN_SECRET` -- auth for the distribute endpoint
- `JUPITER_API_KEY` -- Jupiter Swap API key (optional, burn skipped without it)
- `BURN_AUTHORITY_KEYPAIR` -- base58 secret key for burn operations (optional)
- `NEXT_PUBLIC_RPC_URL` -- Solana RPC endpoint
- `NEXT_PUBLIC_GSD_MINT` -- $GSD token mint address
  </action>
  <verify>TypeScript compiles. POST endpoint exports correctly. Manual test: `curl -X POST http://localhost:3000/api/revenue/distribute -H "Authorization: test-secret" -H "Content-Type: application/json" -d '{"totalAmount":"1000000000","token":"sol","originSignature":"test123"}' ` returns 200 with split data (or 401 if secret mismatch).</verify>
  <done>Distribution API endpoint accepts admin-authenticated POST, computes 60/20/10/10 split, persists to database, attempts Jupiter buy-and-burn, returns distribution result</done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes
2. Jupiter quote/swap flow handles API errors gracefully (returns null, not throw)
3. Distribution endpoint requires authentication
4. Idempotency: duplicate originSignature returns 409
5. Splits computed correctly: 10 SOL -> 6/2/1/1
6. Missing burn authority logs warning but doesn't fail distribution
7. Distributor can import detectRevenueInflow from detection.ts (created in plan 04-03)
</verification>

<success_criteria>
- Jupiter Swap API integration quotes and builds swap transactions
- Buy-and-burn failure doesn't block other distributions
- Distribution endpoint is admin-authenticated and idempotent
- Distribution endpoint can process PendingRevenue records (from admin review of detected inflows)
- All BigInt values handled correctly across API boundary
</success_criteria>

<output>
After completion, create `.planning/phases/04-revenue-mechanics/04-04-SUMMARY.md`
</output>
