---
phase: 04-revenue-mechanics
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - apps/web/lib/revenue/constants.ts
  - apps/web/lib/revenue/detection.ts
  - apps/web/lib/revenue/indexer.ts
  - apps/web/app/api/webhooks/helius/route.ts
  - apps/web/app/api/revenue/events/route.ts
  - apps/web/app/api/revenue/claims/route.ts
  - apps/web/app/api/revenue/burns/route.ts
  - apps/web/app/api/revenue/summary/route.ts
autonomous: true

must_haves:
  truths:
    - "Revenue events (SOL/USDC inflows to treasury) are detected by the Helius webhook via detectRevenueInflow and persisted as PendingRevenue records for admin review"
    - "Revenue API returns paginated event list with split breakdowns"
    - "Claims API returns per-wallet claim history across all revenue events"
    - "Burns API returns burn history with traceability to originating revenue events"
    - "Summary API returns aggregate revenue, distribution, and burn totals"
  artifacts:
    - path: "apps/web/lib/revenue/constants.ts"
      provides: "Revenue instruction discriminator map for webhook indexer"
      exports: ["REVENUE_DISCRIMINATORS", "REVENUE_DISCRIMINATOR_TO_INSTRUCTION"]
    - path: "apps/web/lib/revenue/detection.ts"
      provides: "Revenue inflow detection logic for SOL/USDC treasury transfers"
      exports: ["detectRevenueInflow", "USDC_MINT_STR"]
    - path: "apps/web/lib/revenue/indexer.ts"
      provides: "Revenue event processor and treasury inflow detector for Helius webhook"
      exports: ["processRevenueEvent", "processRevenueDetection"]
    - path: "apps/web/app/api/revenue/events/route.ts"
      provides: "GET /api/revenue/events endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/revenue/claims/route.ts"
      provides: "GET /api/revenue/claims endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/revenue/burns/route.ts"
      provides: "GET /api/revenue/burns endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/revenue/summary/route.ts"
      provides: "GET /api/revenue/summary endpoint"
      exports: ["GET"]
  key_links:
    - from: "apps/web/lib/revenue/indexer.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "Prisma upsert for RevenueEvent records"
      pattern: "prisma\\.revenueEvent\\.upsert"
    - from: "apps/web/app/api/webhooks/helius/route.ts"
      to: "apps/web/lib/revenue/indexer.ts"
      via: "processRevenueEvent and processRevenueDetection called in webhook handler"
      pattern: "processRevenueEvent|processRevenueDetection"
    - from: "apps/web/lib/revenue/indexer.ts"
      to: "apps/web/lib/revenue/detection.ts"
      via: "processRevenueDetection calls detectRevenueInflow and persists PendingRevenue"
      pattern: "detectRevenueInflow|pendingRevenue"
    - from: "apps/web/app/api/revenue/events/route.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "Prisma findMany for RevenueEvent"
      pattern: "prisma\\.revenueEvent\\.findMany"
---

<objective>
Create the revenue event indexer for Helius webhooks and four API endpoints serving revenue data (events, claims, burns, summary).

Purpose: Bridge on-chain revenue events to the off-chain database and provide API access for the treasury dashboard UI.
Output: Revenue indexer, webhook extension, 4 API routes
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-revenue-mechanics/04-RESEARCH.md
@.planning/phases/04-revenue-mechanics/04-01-SUMMARY.md
@.planning/phases/04-revenue-mechanics/04-02-SUMMARY.md

# Existing webhook and indexer patterns
@apps/web/app/api/webhooks/helius/route.ts
@apps/web/lib/governance/indexer.ts
@apps/web/lib/governance/constants.ts
@apps/web/lib/contributions/indexer.ts

# Existing API patterns
@apps/web/app/api/governance/rounds/route.ts
@apps/web/app/api/governance/votes/route.ts
@apps/web/app/api/treasury/route.ts

# Prisma client
@apps/web/lib/db/index.ts

# Types
@packages/types/src/revenue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create revenue indexer and extend Helius webhook</name>
  <files>
    apps/web/lib/revenue/constants.ts
    apps/web/lib/revenue/detection.ts
    apps/web/lib/revenue/indexer.ts
    apps/web/app/api/webhooks/helius/route.ts
  </files>
  <action>
**apps/web/lib/revenue/constants.ts** -- Revenue instruction discriminator map (follow governance/constants.ts pattern):
- Import crypto (for SHA-256) or use the same inline approach as governance constants
- Compute Anchor discriminators for: `init_revenue_config`, `record_revenue_event`, `claim_revenue_share`, `execute_burn` using SHA-256 of `global:{instruction_name}` taking first 8 bytes
- Export `REVENUE_DISCRIMINATORS` map: `{ init_revenue_config: Buffer, record_revenue_event: Buffer, claim_revenue_share: Buffer, execute_burn: Buffer }`
- Export `REVENUE_DISCRIMINATOR_TO_INSTRUCTION` reverse lookup map for O(1) identification

**apps/web/lib/revenue/indexer.ts** -- Revenue event processor:
- Import `prisma` from `@/lib/db`
- Import `HeliusEnhancedTransaction` from contributions indexer (or define compatible interface)
- Import `REVENUE_DISCRIMINATOR_TO_INSTRUCTION` from constants
- Export `processRevenueEvent(transaction: HeliusEnhancedTransaction): Promise<number>`
- The function processes on-chain revenue events detected in webhook transactions:
  1. Check each instruction for revenue discriminator match
  2. For `record_revenue_event`: parse the accounts from instruction data (event PDA address is the second account), upsert a RevenueEvent record using `originSignature` as the unique key. Extract: eventIndex (from PDA or sequential), token type, total_amount, split amounts from instruction data (or derive from event account). Since instruction data is Borsh-serialized and complex to parse, the simpler approach is: create a STUB record on discriminator match with the transaction signature, then a separate enrichment step reads the on-chain account. For v1: create the RevenueEvent record with the transaction signature and known addresses, set status="recorded", and use the on-chain data from instruction accounts.
  3. For `claim_revenue_share`: upsert a RevenueClaim record linking claimant wallet to the revenue event
  4. For `execute_burn`: update the RevenueEvent's burnSignature and gsdBurned fields
  5. Return count of processed events
- Use `prisma.revenueEvent.upsert` with `transactionSignature` / `originSignature` for idempotency (same pattern as contributions indexer)
- The indexer processes on-chain gsd-hub program instructions (record_revenue_event, claim_revenue_share, execute_burn) via discriminator matching.

**apps/web/lib/revenue/detection.ts** -- Revenue inflow detection logic (moved here from plan 04-04 to wire into webhook):
- Import `TREASURY_ADDRESS_STR` from `@/lib/treasury/client`
- Import `HeliusEnhancedTransaction` type from contributions indexer
- Export `detectRevenueInflow(transaction: HeliusEnhancedTransaction): { token: 'sol' | 'usdc'; amount: bigint } | null`
- Logic:
  1. Check `nativeTransfers` for SOL inflows to TREASURY_ADDRESS_STR where amount > 0
  2. Check `tokenTransfers` for USDC inflows to TREASURY_ADDRESS_STR (USDC mint: `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` for mainnet, configurable via env)
  3. Sum all matching inflows per token type
  4. Return the largest inflow (SOL or USDC), or null if none detected
  5. Ignore outflows and non-treasury transfers
- Export `USDC_MINT_STR` constant: `process.env.NEXT_PUBLIC_USDC_MINT || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"`

**CRITICAL: Wire detectRevenueInflow into the webhook for REVN-01 revenue detection:**
- In addition to processing gsd-hub program instructions, the indexer ALSO calls `detectRevenueInflow` (from `@/lib/revenue/detection`, created above in this plan) on EVERY transaction to detect raw SOL/USDC inflows to the treasury address.
- Import `detectRevenueInflow` from `@/lib/revenue/detection`
- Export a new function `processRevenueDetection(transaction: HeliusEnhancedTransaction): Promise<number>` in indexer.ts:
  1. Call `detectRevenueInflow(transaction)` -- returns `{ token, amount } | null`
  2. If an inflow is detected, persist it as a `PendingRevenue` record in the database:
     ```typescript
     await prisma.pendingRevenue.upsert({
       where: { transactionSignature: transaction.signature },
       create: {
         transactionSignature: transaction.signature,
         token: inflow.token,
         amount: inflow.amount,
         fromAddress: extractSender(transaction),
         status: 'pending',
       },
       update: {}, // idempotent -- don't overwrite existing
     });
     ```
  3. Return 1 if a pending revenue record was created/existed, 0 otherwise.
- The `PendingRevenue` model is defined in plan 04-01 (Prisma schema). The admin reviews pending revenue records via the dashboard or a future admin UI, then triggers distribution via `POST /api/revenue/distribute` (plan 04-04) which processes the pending record.
- Helper function `extractSender(tx)`: return the first `nativeTransfers` entry's `fromUserAccount` or null if not identifiable.

**apps/web/app/api/webhooks/helius/route.ts** -- Extend existing webhook:
- Import `processRevenueEvent` and `processRevenueDetection` from `@/lib/revenue/indexer`
- Import `detectRevenueInflow` from `@/lib/revenue/detection`
- Add TWO revenue processing steps alongside existing contribution and governance processors:
  ```
  // Step 1: Process gsd-hub revenue instructions (record/claim/burn)
  try {
    const count = await processRevenueEvent(tx);
    revenueProcessed += count;
  } catch (error) { ... }

  // Step 2: Detect raw SOL/USDC treasury inflows and persist as PendingRevenue
  try {
    const count = await processRevenueDetection(tx);
    revenueDetected += count;
  } catch (error) { ... }
  ```
- Add `revenueProcessed` and `revenueDetected` counters to response JSON
- Follow exact existing pattern (try/catch per processor, error accumulation, summary response)
  </action>
  <verify>TypeScript compiles: `cd apps/web && npx tsc --noEmit` (or at minimum no red squiggles in the new files). Webhook handler still exports POST function. processRevenueDetection function exists and calls detectRevenueInflow.</verify>
  <done>Revenue indexer processes 4 instruction types AND detects raw treasury inflows as PendingRevenue records. Webhook routes transactions through 4 processors (contribution + governance + revenue instructions + revenue detection). Constants file has discriminator map. detectRevenueInflow is wired into the webhook pipeline.</done>
</task>

<task type="auto">
  <name>Task 2: Create revenue API endpoints</name>
  <files>
    apps/web/app/api/revenue/events/route.ts
    apps/web/app/api/revenue/claims/route.ts
    apps/web/app/api/revenue/burns/route.ts
    apps/web/app/api/revenue/summary/route.ts
  </files>
  <action>
Create 4 API route files following the pagination pattern from governance routes:

**GET /api/revenue/events** (`apps/web/app/api/revenue/events/route.ts`):
- Query params: `page` (default 1), `limit` (default 20, max 100), `status` (optional filter: recorded/distributing/completed)
- Query `prisma.revenueEvent.findMany` with pagination, optional status filter, order by recordedAt desc
- Include `_count: { claims: true }` to show claim count per event
- Serialize BigInt fields as strings (same convention as governance)
- Return: `{ events: RevenueEventInfo[], total: number, page: number, limit: number }`

**GET /api/revenue/claims** (`apps/web/app/api/revenue/claims/route.ts`):
- Query params: `wallet` (required), `page` (default 1), `limit` (default 20), `eventId` (optional filter)
- If wallet missing, return 400
- Query `prisma.revenueClaim.findMany` filtered by claimantWallet, optional revenueEventId, order by claimedAt desc
- Include `revenueEvent: { select: { eventIndex: true, token: true, totalAmount: true } }` for context
- Serialize BigInt fields as strings
- Return: `{ claims: RevenueClaimInfo[], total: number, page: number, limit: number }`

**GET /api/revenue/burns** (`apps/web/app/api/revenue/burns/route.ts`):
- Query params: `page` (default 1), `limit` (default 20)
- Query `prisma.revenueEvent.findMany` where `burnSignature` is not null, order by recordedAt desc
- Select only burn-relevant fields: eventIndex, token, burnAmount, burnSignature, gsdBurned, originSignature, recordedAt
- Serialize BigInt fields as strings
- Return: `{ burns: BurnRecord[], total: number, page: number, limit: number }`

**GET /api/revenue/summary** (`apps/web/app/api/revenue/summary/route.ts`):
- No params required
- Use Prisma aggregate queries:
  - `prisma.revenueEvent.aggregate({ _sum: { totalAmount: true, burnAmount: true, gsdBurned: true, claimedAmount: true }, _count: true })`
  - Total distributed = sum of claimedAmount across all events
- Return: `{ totalRevenue: string, totalDistributed: string, totalBurnAllocated: string, totalGsdBurned: string, eventCount: number }`
- Add 30-second cache headers (Cache-Control: public, s-maxage=30) matching treasury route pattern

All endpoints: wrap in try/catch, return 500 with error message on failure, return empty arrays with 200 when database unavailable (graceful degradation pattern from Phase 1).
  </action>
  <verify>TypeScript compiles for all 4 route files. Each exports a GET function. Manual test: `curl http://localhost:3000/api/revenue/summary` returns valid JSON (empty data is fine).</verify>
  <done>4 API endpoints return paginated revenue data: events with split breakdowns, per-wallet claims, burn history with traceability, and aggregate summary</done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes (or builds without type errors)
2. Webhook handler processes revenue instructions alongside contribution and governance
3. Webhook handler calls detectRevenueInflow on every transaction and persists PendingRevenue records
4. GET /api/revenue/events returns paginated events
5. GET /api/revenue/claims?wallet=xxx returns per-wallet claims
6. GET /api/revenue/burns returns burn history with origin_signature traceability
7. GET /api/revenue/summary returns aggregate totals
8. BigInt fields serialized as strings in all responses
</verification>

<success_criteria>
- Revenue indexer identifies 4 instruction types via discriminator matching
- detectRevenueInflow is wired into the webhook and persists PendingRevenue records for treasury SOL/USDC inflows
- Webhook extended with revenue processor and revenue detection (4th processor alongside contribution/governance/revenue-instructions)
- 4 API endpoints return correctly structured JSON
- Idempotent indexing (duplicate webhook deliveries handled)
- Graceful degradation when database unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/04-revenue-mechanics/04-03-SUMMARY.md`
</output>
