---
phase: 04-revenue-mechanics
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - apps/web/lib/revenue/constants.ts
  - apps/web/lib/revenue/indexer.ts
  - apps/web/app/api/webhooks/helius/route.ts
  - apps/web/app/api/revenue/events/route.ts
  - apps/web/app/api/revenue/claims/route.ts
  - apps/web/app/api/revenue/burns/route.ts
  - apps/web/app/api/revenue/summary/route.ts
autonomous: true

must_haves:
  truths:
    - "Revenue events (SOL/USDC inflows to treasury) are detected by the Helius webhook and persisted to database"
    - "Revenue API returns paginated event list with split breakdowns"
    - "Claims API returns per-wallet claim history across all revenue events"
    - "Burns API returns burn history with traceability to originating revenue events"
    - "Summary API returns aggregate revenue, distribution, and burn totals"
  artifacts:
    - path: "apps/web/lib/revenue/constants.ts"
      provides: "Revenue instruction discriminator map for webhook indexer"
      exports: ["REVENUE_DISCRIMINATORS", "REVENUE_DISCRIMINATOR_TO_INSTRUCTION"]
    - path: "apps/web/lib/revenue/indexer.ts"
      provides: "Revenue event processor for Helius webhook"
      exports: ["processRevenueEvent"]
    - path: "apps/web/app/api/revenue/events/route.ts"
      provides: "GET /api/revenue/events endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/revenue/claims/route.ts"
      provides: "GET /api/revenue/claims endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/revenue/burns/route.ts"
      provides: "GET /api/revenue/burns endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/revenue/summary/route.ts"
      provides: "GET /api/revenue/summary endpoint"
      exports: ["GET"]
  key_links:
    - from: "apps/web/lib/revenue/indexer.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "Prisma upsert for RevenueEvent records"
      pattern: "prisma\\.revenueEvent\\.upsert"
    - from: "apps/web/app/api/webhooks/helius/route.ts"
      to: "apps/web/lib/revenue/indexer.ts"
      via: "processRevenueEvent called in webhook handler"
      pattern: "processRevenueEvent"
    - from: "apps/web/app/api/revenue/events/route.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "Prisma findMany for RevenueEvent"
      pattern: "prisma\\.revenueEvent\\.findMany"
---

<objective>
Create the revenue event indexer for Helius webhooks and four API endpoints serving revenue data (events, claims, burns, summary).

Purpose: Bridge on-chain revenue events to the off-chain database and provide API access for the treasury dashboard UI.
Output: Revenue indexer, webhook extension, 4 API routes
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-revenue-mechanics/04-RESEARCH.md
@.planning/phases/04-revenue-mechanics/04-01-SUMMARY.md
@.planning/phases/04-revenue-mechanics/04-02-SUMMARY.md

# Existing webhook and indexer patterns
@apps/web/app/api/webhooks/helius/route.ts
@apps/web/lib/governance/indexer.ts
@apps/web/lib/governance/constants.ts
@apps/web/lib/contributions/indexer.ts

# Existing API patterns
@apps/web/app/api/governance/rounds/route.ts
@apps/web/app/api/governance/votes/route.ts
@apps/web/app/api/treasury/route.ts

# Prisma client
@apps/web/lib/db/index.ts

# Types
@packages/types/src/revenue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create revenue indexer and extend Helius webhook</name>
  <files>
    apps/web/lib/revenue/constants.ts
    apps/web/lib/revenue/indexer.ts
    apps/web/app/api/webhooks/helius/route.ts
  </files>
  <action>
**apps/web/lib/revenue/constants.ts** -- Revenue instruction discriminator map (follow governance/constants.ts pattern):
- Import crypto (for SHA-256) or use the same inline approach as governance constants
- Compute Anchor discriminators for: `init_revenue_config`, `record_revenue_event`, `claim_revenue_share`, `execute_burn` using SHA-256 of `global:{instruction_name}` taking first 8 bytes
- Export `REVENUE_DISCRIMINATORS` map: `{ init_revenue_config: Buffer, record_revenue_event: Buffer, claim_revenue_share: Buffer, execute_burn: Buffer }`
- Export `REVENUE_DISCRIMINATOR_TO_INSTRUCTION` reverse lookup map for O(1) identification

**apps/web/lib/revenue/indexer.ts** -- Revenue event processor:
- Import `prisma` from `@/lib/db`
- Import `HeliusEnhancedTransaction` from contributions indexer (or define compatible interface)
- Import `REVENUE_DISCRIMINATOR_TO_INSTRUCTION` from constants
- Export `processRevenueEvent(transaction: HeliusEnhancedTransaction): Promise<number>`
- The function processes on-chain revenue events detected in webhook transactions:
  1. Check each instruction for revenue discriminator match
  2. For `record_revenue_event`: parse the accounts from instruction data (event PDA address is the second account), upsert a RevenueEvent record using `originSignature` as the unique key. Extract: eventIndex (from PDA or sequential), token type, total_amount, split amounts from instruction data (or derive from event account). Since instruction data is Borsh-serialized and complex to parse, the simpler approach is: create a STUB record on discriminator match with the transaction signature, then a separate enrichment step reads the on-chain account. For v1: create the RevenueEvent record with the transaction signature and known addresses, set status="recorded", and use the on-chain data from instruction accounts.
  3. For `claim_revenue_share`: upsert a RevenueClaim record linking claimant wallet to the revenue event
  4. For `execute_burn`: update the RevenueEvent's burnSignature and gsdBurned fields
  5. Return count of processed events
- Use `prisma.revenueEvent.upsert` with `transactionSignature` / `originSignature` for idempotency (same pattern as contributions indexer)
- IMPORTANT: The webhook processes on-chain events. The ACTUAL revenue detection (SOL/USDC arriving at treasury) is handled by a separate detection flow in the distributor (plan 04-04). This indexer processes the gsd-hub program's revenue instructions, NOT raw SOL transfers. Revenue detection via SOL/USDC transfer monitoring is in the distributor's detection logic.

**apps/web/app/api/webhooks/helius/route.ts** -- Extend existing webhook:
- Import `processRevenueEvent` from `@/lib/revenue/indexer`
- Add revenue processing alongside existing contribution and governance processors:
  ```
  // Try revenue processor
  try {
    const count = await processRevenueEvent(tx);
    revenueProcessed += count;
  } catch (error) { ... }
  ```
- Add `revenueProcessed` counter to response JSON
- Follow exact existing pattern (try/catch per processor, error accumulation, summary response)
  </action>
  <verify>TypeScript compiles: `cd apps/web && npx tsc --noEmit` (or at minimum no red squiggles in the new files). Webhook handler still exports POST function.</verify>
  <done>Revenue indexer processes 4 instruction types, webhook routes transactions through 3 processors (contribution + governance + revenue), constants file has discriminator map</done>
</task>

<task type="auto">
  <name>Task 2: Create revenue API endpoints</name>
  <files>
    apps/web/app/api/revenue/events/route.ts
    apps/web/app/api/revenue/claims/route.ts
    apps/web/app/api/revenue/burns/route.ts
    apps/web/app/api/revenue/summary/route.ts
  </files>
  <action>
Create 4 API route files following the pagination pattern from governance routes:

**GET /api/revenue/events** (`apps/web/app/api/revenue/events/route.ts`):
- Query params: `page` (default 1), `limit` (default 20, max 100), `status` (optional filter: recorded/distributing/completed)
- Query `prisma.revenueEvent.findMany` with pagination, optional status filter, order by recordedAt desc
- Include `_count: { claims: true }` to show claim count per event
- Serialize BigInt fields as strings (same convention as governance)
- Return: `{ events: RevenueEventInfo[], total: number, page: number, limit: number }`

**GET /api/revenue/claims** (`apps/web/app/api/revenue/claims/route.ts`):
- Query params: `wallet` (required), `page` (default 1), `limit` (default 20), `eventId` (optional filter)
- If wallet missing, return 400
- Query `prisma.revenueClaim.findMany` filtered by claimantWallet, optional revenueEventId, order by claimedAt desc
- Include `revenueEvent: { select: { eventIndex: true, token: true, totalAmount: true } }` for context
- Serialize BigInt fields as strings
- Return: `{ claims: RevenueClaimInfo[], total: number, page: number, limit: number }`

**GET /api/revenue/burns** (`apps/web/app/api/revenue/burns/route.ts`):
- Query params: `page` (default 1), `limit` (default 20)
- Query `prisma.revenueEvent.findMany` where `burnSignature` is not null, order by recordedAt desc
- Select only burn-relevant fields: eventIndex, token, burnAmount, burnSignature, gsdBurned, originSignature, recordedAt
- Serialize BigInt fields as strings
- Return: `{ burns: BurnRecord[], total: number, page: number, limit: number }`

**GET /api/revenue/summary** (`apps/web/app/api/revenue/summary/route.ts`):
- No params required
- Use Prisma aggregate queries:
  - `prisma.revenueEvent.aggregate({ _sum: { totalAmount: true, burnAmount: true, gsdBurned: true, claimedAmount: true }, _count: true })`
  - Total distributed = sum of claimedAmount across all events
- Return: `{ totalRevenue: string, totalDistributed: string, totalBurnAllocated: string, totalGsdBurned: string, eventCount: number }`
- Add 30-second cache headers (Cache-Control: public, s-maxage=30) matching treasury route pattern

All endpoints: wrap in try/catch, return 500 with error message on failure, return empty arrays with 200 when database unavailable (graceful degradation pattern from Phase 1).
  </action>
  <verify>TypeScript compiles for all 4 route files. Each exports a GET function. Manual test: `curl http://localhost:3000/api/revenue/summary` returns valid JSON (empty data is fine).</verify>
  <done>4 API endpoints return paginated revenue data: events with split breakdowns, per-wallet claims, burn history with traceability, and aggregate summary</done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes (or builds without type errors)
2. Webhook handler processes revenue instructions alongside contribution and governance
3. GET /api/revenue/events returns paginated events
4. GET /api/revenue/claims?wallet=xxx returns per-wallet claims
5. GET /api/revenue/burns returns burn history with origin_signature traceability
6. GET /api/revenue/summary returns aggregate totals
7. BigInt fields serialized as strings in all responses
</verification>

<success_criteria>
- Revenue indexer identifies 4 instruction types via discriminator matching
- Webhook extended with revenue processor (3rd processor alongside contribution/governance)
- 4 API endpoints return correctly structured JSON
- Idempotent indexing (duplicate webhook deliveries handled)
- Graceful degradation when database unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/04-revenue-mechanics/04-03-SUMMARY.md`
</output>
