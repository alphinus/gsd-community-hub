---
phase: 04-revenue-mechanics
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - programs/gsd-hub/src/instructions/init_revenue_config.rs
  - programs/gsd-hub/src/instructions/record_revenue_event.rs
  - programs/gsd-hub/src/instructions/claim_revenue_share.rs
  - programs/gsd-hub/src/instructions/execute_burn.rs
  - programs/gsd-hub/src/instructions/mod.rs
  - programs/gsd-hub/src/lib.rs
  - programs/gsd-hub/tests/revenue.test.ts
autonomous: true

must_haves:
  truths:
    - "Admin can initialize revenue config with 60/20/10/10 split ratios that sum to 10000 bps"
    - "Authority can record a revenue event that computes the 4-way split and transfers developer_pool SOL to a vault PDA"
    - "Contributor can claim their proportional share based on contribution_score / total_contribution_score with actual SOL transfer from vault PDA"
    - "Burn authority can record a burn event that updates the RevenueEvent with burn signature and GSD amount"
    - "Double-claiming is prevented by PDA uniqueness (init, not init_if_needed)"
    - "All bankrun tests pass for the 4 revenue instructions"
  artifacts:
    - path: "programs/gsd-hub/src/instructions/init_revenue_config.rs"
      provides: "Revenue config initialization instruction"
      contains: "pub struct InitRevenueConfig"
    - path: "programs/gsd-hub/src/instructions/record_revenue_event.rs"
      provides: "Revenue event recording with split calculation"
      contains: "pub struct RecordRevenueEvent"
    - path: "programs/gsd-hub/src/instructions/claim_revenue_share.rs"
      provides: "Contribution-weighted claim instruction"
      contains: "pub struct ClaimRevenueShare"
    - path: "programs/gsd-hub/src/instructions/execute_burn.rs"
      provides: "Burn recording instruction with traceability"
      contains: "pub struct ExecuteBurn"
    - path: "programs/gsd-hub/tests/revenue.test.ts"
      provides: "Bankrun test suite for all revenue instructions"
      contains: "describe.*revenue"
  key_links:
    - from: "programs/gsd-hub/src/instructions/claim_revenue_share.rs"
      to: "programs/gsd-hub/src/state/revenue_event.rs"
      via: "reads developer_pool and total_contribution_score from RevenueEvent, transfers SOL from vault PDA to claimant"
      pattern: "revenue_event\\.developer_pool.*developer_pool_vault"
    - from: "programs/gsd-hub/src/instructions/claim_revenue_share.rs"
      to: "programs/gsd-hub/src/state/developer.rs"
      via: "reads contribution_score from DeveloperProfile"
      pattern: "developer_profile\\.contribution_score"
    - from: "programs/gsd-hub/src/instructions/execute_burn.rs"
      to: "programs/gsd-hub/src/state/revenue_event.rs"
      via: "writes burn_signature and gsd_burned to RevenueEvent"
      pattern: "revenue_event\\.burn_signature.*revenue_event\\.gsd_burned"
---

<objective>
Implement four on-chain revenue instructions (init_revenue_config, record_revenue_event, claim_revenue_share, execute_burn) with comprehensive bankrun tests covering the full revenue lifecycle.

Purpose: The economic core of the platform -- these instructions enforce the 60/20/10/10 split, contribution-weighted claims, and burn traceability on-chain.
Output: 4 instruction files, updated lib.rs/mod.rs, bankrun test suite
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-revenue-mechanics/04-RESEARCH.md
@.planning/phases/04-revenue-mechanics/04-01-SUMMARY.md

# Existing instruction patterns
@programs/gsd-hub/src/instructions/init_governance_config.rs
@programs/gsd-hub/src/instructions/deposit_tokens.rs
@programs/gsd-hub/src/instructions/cast_vote.rs
@programs/gsd-hub/src/lib.rs
@programs/gsd-hub/src/instructions/mod.rs

# State structs (from plan 01)
@programs/gsd-hub/src/state/revenue_config.rs
@programs/gsd-hub/src/state/revenue_event.rs
@programs/gsd-hub/src/state/revenue_claim.rs
@programs/gsd-hub/src/state/developer.rs
@programs/gsd-hub/src/errors.rs

# Existing test patterns
@programs/gsd-hub/tests/contribution.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement four revenue instructions</name>
  <files>
    programs/gsd-hub/src/instructions/init_revenue_config.rs
    programs/gsd-hub/src/instructions/record_revenue_event.rs
    programs/gsd-hub/src/instructions/claim_revenue_share.rs
    programs/gsd-hub/src/instructions/execute_burn.rs
    programs/gsd-hub/src/instructions/mod.rs
    programs/gsd-hub/src/lib.rs
  </files>
  <action>
Create four instruction files in `programs/gsd-hub/src/instructions/`:

**init_revenue_config.rs** -- Initialize the revenue config singleton PDA:
- Accounts: `revenue_config` (init, payer=admin, space=8+RevenueConfig::INIT_SPACE, seeds=[b"revenue_config"], bump), `admin` (Signer, mut), `system_program`
- Handler args: `treasury_address: Pubkey`, `maintenance_address: Pubkey`, `gsd_mint: Pubkey`, `usdc_mint: Pubkey`, `min_revenue_threshold: u64`
- Set default split: developer_bps=6000, treasury_bps=2000, burn_bps=1000, maintenance_bps=1000
- Validate bps sum to 10000 (return RevenueError::InvalidSplitRatios if not)
- Set admin, bump, addresses, event_count=0, threshold

**record_revenue_event.rs** -- Record a new revenue event with computed splits and fund the developer pool vault:
- Accounts: `revenue_config` (mut, seeds=[b"revenue_config"], bump=revenue_config.bump), `revenue_event` (init, payer=authority, space=8+RevenueEvent::INIT_SPACE, seeds=[b"revenue_event", &revenue_config.event_count.to_le_bytes()], bump), `developer_pool_vault` (mut, SystemAccount, seeds=[b"revenue_vault", &revenue_config.event_count.to_le_bytes()], bump -- the PDA vault that will hold the developer pool SOL for this event), `authority` (Signer, mut -- must equal revenue_config.admin), `system_program`
- Handler args: `total_amount: u64`, `token: RevenueToken`, `origin_signature: [u8; 64]`, `total_contribution_score: u64`
- Validate: total_amount >= revenue_config.min_revenue_threshold (RevenueError::BelowMinimumThreshold)
- Validate: authority == revenue_config.admin (RevenueError::UnauthorizedBurnAuthority -- reuse or add dedicated error)
- Compute splits using basis points: `developer_pool = total_amount * developer_bps / 10000`, same for treasury_reserve, burn_amount, maintenance_amount. Handle rounding: assign any remainder (total_amount - sum of 4 parts) to developer_pool.
- **Transfer developer_pool SOL to the vault PDA**: Use `system_program::transfer` CPI from `authority` to `developer_pool_vault` for the `developer_pool` amount. The authority (admin) must have sufficient SOL to fund the vault. This means the server-side distributor sends the admin the developer_pool SOL before calling record_revenue_event, or the admin already holds the revenue.
- Set all fields on revenue_event, status=Recorded, recorded_at=Clock::get()?.unix_timestamp
- Store the vault bump on the revenue_event for later use: add a `vault_bump: u8` field (if not already in the struct, store it; alternatively, the claim instruction can re-derive it)
- Increment revenue_config.event_count

**claim_revenue_share.rs** -- Contributor claims their weighted share with actual SOL transfer from vault:
- Accounts: `revenue_event` (mut, seeds=[b"revenue_event", &revenue_event.event_index.to_le_bytes()], bump=revenue_event.bump), `revenue_claim` (init, payer=claimant, space=8+RevenueClaim::INIT_SPACE, seeds=[b"revenue_claim", claimant.key().as_ref(), revenue_event.key().as_ref()], bump), `developer_profile` (seeds=[b"developer", claimant.key().as_ref()], bump -- read the developer profile to get contribution_score), `claimant` (Signer, mut), `developer_pool_vault` (mut, seeds=[b"revenue_vault", &revenue_event.event_index.to_le_bytes()], bump -- the PDA vault holding the developer pool SOL), `system_program`
- IMPORTANT: Use `init` (NOT `init_if_needed`) for revenue_claim -- this prevents double-claiming because Anchor's init constraint fails if PDA already exists.
- Validate: revenue_event.status == Recorded or Distributing (not Completed)
- Validate: developer_profile.contribution_score > 0 (RevenueError::NoContributionScore)
- Validate: revenue_event.total_contribution_score > 0 (RevenueError::DivisionByZero)
- Calculate share: `amount = developer_pool * contribution_score / total_contribution_score` (use u128 intermediary to prevent overflow)
- Validate: developer_pool_vault has sufficient lamports for the transfer (RevenueError::InsufficientEscrowBalance)
- **For SOL claims: Transfer lamports from developer_pool_vault PDA to claimant using PDA-signed CPI.** The vault PDA seeds are [b"revenue_vault", event_index.to_le_bytes()]. Use `system_program::transfer` with `CpiContext::new_with_signer` providing the vault seeds + bump as signer_seeds. Example:
  ```rust
  let event_index_bytes = revenue_event.event_index.to_le_bytes();
  let vault_seeds = &[b"revenue_vault".as_ref(), event_index_bytes.as_ref(), &[vault_bump]];
  let signer_seeds = &[&vault_seeds[..]];
  system_program::transfer(
      CpiContext::new_with_signer(
          ctx.accounts.system_program.to_account_info(),
          system_program::Transfer {
              from: ctx.accounts.developer_pool_vault.to_account_info(),
              to: ctx.accounts.claimant.to_account_info(),
          },
          signer_seeds,
      ),
      amount,
  )?;
  ```
- **For USDC claims (future enhancement):** Would require the vault PDA to own an ATA for USDC, and use `anchor_spl::token::transfer` with PDA signing. For v1, focus on SOL claims. USDC support can be added by passing additional token accounts (vault_token_account, claimant_token_account, token_program) when the revenue event token is USDC.
- Set all claim fields: claimant, revenue_event key, bump, contribution_score, total_score, amount, claimed_at
- Update revenue_event.claimed_amount += amount

**execute_burn.rs** -- Record a completed burn on the revenue event:
- Accounts: `revenue_event` (mut, seeds=[b"revenue_event", &revenue_event.event_index.to_le_bytes()], bump=revenue_event.bump), `burn_authority` (Signer -- must match revenue_config.admin), `revenue_config` (seeds=[b"revenue_config"], bump=revenue_config.bump), `gsd_token_account` (mut, token::TokenAccount), `gsd_mint` (mut, token::Mint), `token_program` (Program<Token>)
- Handler args: `gsd_amount: u64`, `burn_tx_signature: [u8; 64]`
- Validate: burn_authority == revenue_config.admin
- Validate: revenue_event.burn_signature is all zeros (RevenueError::BurnAlreadyExecuted)
- Execute SPL token burn via CPI: `anchor_spl::token::burn` with authority=burn_authority, from=gsd_token_account, mint=gsd_mint
- Update revenue_event.burn_signature = burn_tx_signature
- Update revenue_event.gsd_burned = gsd_amount
- If all conditions met (claimed_amount approaches developer_pool, burn recorded), update status to Completed. For v1 simplicity: mark Completed after burn is recorded (distribution tracking can be enhanced later).

**Update instructions/mod.rs**: Add 4 new modules and pub use statements.

**Update lib.rs**: Add 4 new instruction entry points in the `#[program]` block:
- `init_revenue_config(ctx, treasury_address, maintenance_address, gsd_mint, usdc_mint, min_revenue_threshold)`
- `record_revenue_event(ctx, total_amount, token, origin_signature, total_contribution_score)` -- import RevenueToken in lib.rs
- `claim_revenue_share(ctx)`
- `execute_burn(ctx, gsd_amount, burn_tx_signature)`

Import `RevenueToken` (and `RevenueStatus` if needed) alongside existing `QuorumType, VoteChoice` imports in lib.rs.
  </action>
  <verify>Run `cd programs/gsd-hub && cargo check` -- all 4 instructions compile. Run `anchor build` to generate updated IDL.</verify>
  <done>4 revenue instructions compile, lib.rs has all entry points, IDL generated with new instructions</done>
</task>

<task type="auto">
  <name>Task 2: Write bankrun tests for revenue instructions</name>
  <files>
    programs/gsd-hub/tests/revenue.test.ts
  </files>
  <action>
Create `programs/gsd-hub/tests/revenue.test.ts` following the pattern from `contribution.test.ts` and governance tests:

**Setup**: Use `startAnchor` with extra programs from `tests/fixtures/` (spl_token.so, spl_account_compression.so, spl_noop.so). Create `BankrunProvider` and `Program<GsdHub>`. Load IDL from `target/idl/gsd_hub.json`.

**Test cases** (each test creates an isolated bankrun context):

1. **"initializes revenue config with 60/20/10/10 split"**
   - Call `init_revenue_config` with treasury, maintenance, gsd_mint, usdc_mint addresses, and min_revenue_threshold
   - Fetch the RevenueConfig PDA account
   - Assert: developer_bps=6000, treasury_bps=2000, burn_bps=1000, maintenance_bps=1000
   - Assert: event_count=0, admin matches signer

2. **"records a revenue event with correct split amounts and funds vault"**
   - Init config first, then call `record_revenue_event` with total_amount=10_000_000_000 (10 SOL), token=Sol, a dummy origin_signature, total_contribution_score=1000
   - Fund the authority/admin with sufficient SOL (the admin transfers developer_pool SOL to the vault during record_revenue_event)
   - Fetch the RevenueEvent PDA
   - Assert: developer_pool = 6_000_000_000, treasury_reserve = 2_000_000_000, burn_amount = 1_000_000_000, maintenance_amount = 1_000_000_000
   - Assert: status = Recorded, total_contribution_score = 1000, claimed_amount = 0
   - Assert: revenue_config.event_count = 1
   - **Assert: developer_pool_vault PDA balance = 6_000_000_000 lamports** (the vault was funded)

3. **"rejects revenue below minimum threshold"**
   - Init config with min_revenue_threshold = 100_000_000 (0.1 SOL)
   - Try to record event with total_amount = 50_000_000 (0.05 SOL)
   - Assert: fails with BelowMinimumThreshold error

4. **"contributor claims revenue share proportional to score with SOL transfer"**
   - Init config, register a developer (using register_developer), update their contribution score (using update_contribution_score), record a revenue event (which funds the vault)
   - Record the claimant's SOL balance before claim
   - Call `claim_revenue_share` as the contributor (passing developer_pool_vault PDA as account)
   - Fetch RevenueClaim PDA
   - Assert: amount = developer_pool * contributor_score / total_score
   - Assert: revenue_event.claimed_amount updated
   - **Assert: claimant's SOL balance increased by the claim amount** (actual transfer occurred)
   - **Assert: developer_pool_vault balance decreased by the claim amount**

5. **"prevents double-claiming for same event"**
   - After successful claim from test 4 setup, attempt second claim_revenue_share
   - Assert: fails (PDA already initialized)

6. **"records burn with traceability"**
   - Init config, record event, create a $GSD mint and token account (follow the pattern from governance tests for mint creation), mint some $GSD tokens to burn authority's ATA
   - Call `execute_burn` with gsd_amount and a dummy burn_tx_signature
   - Fetch RevenueEvent PDA
   - Assert: burn_signature matches input, gsd_burned matches input
   - Assert: $GSD token balance reduced by gsd_amount

7. **"prevents double burn on same event"**
   - After recording a burn, attempt second execute_burn
   - Assert: fails with BurnAlreadyExecuted error

Use `BN` from `@coral-xyz/anchor` for u64 args (per existing decision). Use `new Uint8Array(64)` for dummy signatures. For the RevenueToken enum, pass the Anchor-generated enum variant (e.g., `{ sol: {} }`).
  </action>
  <verify>Run `cd programs/gsd-hub && anchor test` -- all revenue tests pass. Existing contribution and governance tests should also still pass.</verify>
  <done>7 bankrun tests pass covering init, record, claim, double-claim prevention, burn, and double-burn prevention. Existing tests unbroken.</done>
</task>

</tasks>

<verification>
1. `anchor build` succeeds with no errors
2. `anchor test` passes all revenue tests (7 tests)
3. Existing contribution and governance tests still pass
4. IDL at `target/idl/gsd_hub.json` includes all 4 new instructions
5. Split calculation: 10 SOL input -> 6/2/1/1 SOL output
6. Double-claim protection verified by test
7. Burn traceability verified by test
</verification>

<success_criteria>
- 4 revenue instructions implemented and compiling
- 7 bankrun tests passing
- Split ratios enforced (60/20/10/10)
- Contribution-weighted claim math correct (u128 intermediate) with actual SOL transfer from vault PDA
- Double-claim prevented via PDA init uniqueness
- Burn updates RevenueEvent with signature and amount
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-revenue-mechanics/04-02-SUMMARY.md`
</output>
