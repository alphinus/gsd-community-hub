---
phase: 03-governance-idea-rounds
plan: 05
type: execute
wave: 4
depends_on: ["03-02", "03-04"]
files_modified:
  - apps/web/lib/governance/indexer.ts
  - apps/web/lib/governance/constants.ts
  - apps/web/app/api/webhooks/helius/route.ts
  - apps/web/app/api/governance/rounds/route.ts
  - apps/web/app/api/governance/rounds/[id]/route.ts
  - apps/web/app/api/governance/rounds/[id]/ideas/route.ts
  - apps/web/app/api/governance/deposit/route.ts
  - apps/web/app/api/governance/votes/route.ts
autonomous: true

must_haves:
  truths:
    - "Helius webhook correctly processes governance on-chain events into the database"
    - "API returns list of rounds with status and idea counts"
    - "API returns ideas within a round with vote tallies"
    - "API returns user's deposit status and voting power"
    - "API returns vote history for an idea"
  artifacts:
    - path: "apps/web/lib/governance/indexer.ts"
      provides: "Governance event processor for Helius webhook"
      exports: ["processGovernanceEvent"]
    - path: "apps/web/lib/governance/constants.ts"
      provides: "Governance instruction discriminators and program constants"
      exports: ["GOVERNANCE_DISCRIMINATORS"]
    - path: "apps/web/app/api/governance/rounds/route.ts"
      provides: "GET /api/governance/rounds -- list rounds with pagination"
      exports: ["GET"]
    - path: "apps/web/app/api/governance/rounds/[id]/route.ts"
      provides: "GET /api/governance/rounds/:id -- single round with stats"
      exports: ["GET"]
    - path: "apps/web/app/api/governance/rounds/[id]/ideas/route.ts"
      provides: "GET /api/governance/rounds/:id/ideas -- ideas in round"
      exports: ["GET"]
    - path: "apps/web/app/api/governance/deposit/route.ts"
      provides: "GET /api/governance/deposit?wallet=... -- user deposit status"
      exports: ["GET"]
    - path: "apps/web/app/api/governance/votes/route.ts"
      provides: "GET /api/governance/votes?ideaId=... -- vote history for idea"
      exports: ["GET"]
  key_links:
    - from: "apps/web/app/api/webhooks/helius/route.ts"
      to: "apps/web/lib/governance/indexer.ts"
      via: "processGovernanceEvent called for governance instructions"
      pattern: "processGovernanceEvent"
    - from: "apps/web/lib/governance/indexer.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "Prisma upsert for IdeaRound, Idea, Vote, VoteDeposit"
      pattern: "prisma\\.(ideaRound|idea|vote|voteDeposit)"
    - from: "apps/web/app/api/governance/rounds/route.ts"
      to: "apps/web/prisma/schema.prisma"
      via: "Prisma query for IdeaRound records"
      pattern: "prisma\\.ideaRound\\.findMany"
---

<objective>
Extend the Helius webhook handler to process governance on-chain events, and create API endpoints for rounds, ideas, deposits, and votes.

Purpose: The webhook indexer bridges on-chain governance events to the PostgreSQL database (satisfying real-time sync requirement). The API endpoints serve the governance UI with paginated, query-ready data for rounds, ideas, voting history, and deposit status.

Output: Governance indexer, extended webhook handler, 5 API route files serving governance data.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-governance-idea-rounds/03-RESEARCH.md
@.planning/phases/03-governance-idea-rounds/03-02-SUMMARY.md
@.planning/phases/03-governance-idea-rounds/03-04-SUMMARY.md

@apps/web/app/api/webhooks/helius/route.ts
@apps/web/lib/contributions/indexer.ts
@apps/web/app/api/contributions/[wallet]/route.ts
@apps/web/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create governance indexer and extend Helius webhook</name>
  <files>
    apps/web/lib/governance/indexer.ts
    apps/web/lib/governance/constants.ts
    apps/web/app/api/webhooks/helius/route.ts
  </files>
  <action>
    1. Create `apps/web/lib/governance/constants.ts`:
       - Export `GSD_PROGRAM_ID` (import from existing config or hardcode: "Gn3kafdEiBZ51T5ewMTtXLUDYzECk87kPwxDAjspqYhw")
       - Export instruction discriminators for governance instructions. Compute SHA-256 of Anchor discriminator format:
         - `create_round`: first 8 bytes of SHA-256("global:create_round")
         - `submit_idea`: first 8 bytes of SHA-256("global:submit_idea")
         - `transition_round`: first 8 bytes of SHA-256("global:transition_round")
         - `cast_vote`: first 8 bytes of SHA-256("global:cast_vote")
         - `deposit_tokens`: first 8 bytes of SHA-256("global:deposit_tokens")
         - `withdraw_tokens`: first 8 bytes of SHA-256("global:withdraw_tokens")
         - `relinquish_vote`: first 8 bytes of SHA-256("global:relinquish_vote")
         - `veto_idea`: first 8 bytes of SHA-256("global:veto_idea")
       - Export as hex strings in a `GOVERNANCE_DISCRIMINATORS` object
       - Actually -- the simpler approach used in Phase 2 was to check accountData from the enhanced transaction, not raw discriminators. Helius enhanced transactions provide parsed account data. Match by checking which accounts were modified (IdeaRound, Idea, VoteDeposit, VoteRecord addresses).

       **Recommended approach:** Use the same pattern as the contribution indexer -- check the program ID in the transaction's instructions, then process the account changes. Since Helius enhanced transactions include `accountData` with parsed/raw account data changes, check for known PDA patterns.

       Actually, the simplest robust approach: Look at which accounts changed and their data. For indexing purposes, the key events are:
       - New IdeaRound account created (round creation)
       - New Idea account created (idea submission)
       - IdeaRound status changed (transition)
       - New VoteDeposit or changed VoteDeposit (deposit/withdraw)
       - New VoteRecord created (vote cast)

       Store the discriminators as constants but use them to identify instruction types from the transaction's instruction data.

    2. Create `apps/web/lib/governance/indexer.ts`:
       - Import `HeliusEnhancedTransaction` type from contributions indexer (or redefine)
       - Import Prisma client
       - Export `async function processGovernanceEvent(tx: HeliusEnhancedTransaction): Promise<number>`
       - For each transaction:
         a. Check if any instruction targets the gsd-hub program ID
         b. Try to identify the instruction type from the instruction data discriminator
         c. Based on instruction type, extract relevant data from account changes:
            - **create_round**: Find the new IdeaRound account in accountData, decode fields (use Borsh-like deserialization or extract from account data). Create IdeaRound record in Prisma. For the title/description, these are off-chain only -- the on-chain data has content_hash. Create a minimal record with on-chain data; the frontend will submit title/description via API when creating the round.
            - **submit_idea**: Find new Idea account, create Idea record. Same approach -- title/description are off-chain.
            - **transition_round**: Find modified IdeaRound account, update status in Prisma.
            - **cast_vote**: Find new VoteRecord account, create Vote record in Prisma. Update Idea vote tallies.
            - **deposit_tokens/withdraw_tokens**: Find modified VoteDeposit, upsert VoteDeposit record.
            - **veto_idea**: Find modified Idea, update status to "vetoed".
         d. Use Prisma upsert with transactionSignature for idempotency (same pattern as contribution indexer)
       - Return count of processed events

       **Pragmatic simplification for v1:** Since the off-chain data (title, description) is not on-chain, the indexer only needs to create/update records with on-chain data. The API will have a POST endpoint where the frontend submits the off-chain content when creating rounds/ideas (the on-chain tx and the API call happen together from the client). The webhook just ensures on-chain state is synced.

       For account data parsing, use the inline approach from the contribution indexer: read raw bytes at known offsets based on the account struct layout (discriminator 8 bytes, then fields in order).

    3. Extend `apps/web/app/api/webhooks/helius/route.ts`:
       - Import `processGovernanceEvent` from `@/lib/governance/indexer`
       - After processing contribution events, also process governance events
       - Update the response to include governance processing count
       - Structure: for each transaction, try contribution processing first, then governance processing. A single transaction can't be both (different instruction types), so whichever matches processes it.
  </action>
  <verify>
    Verify the webhook route compiles: `cd apps/web && npx tsc --noEmit` (or partial check). Verify the indexer imports resolve.
  </verify>
  <done>Governance indexer processes all governance instruction types. Webhook handler routes governance transactions to the new indexer. Both compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create governance API endpoints</name>
  <files>
    apps/web/app/api/governance/rounds/route.ts
    apps/web/app/api/governance/rounds/[id]/route.ts
    apps/web/app/api/governance/rounds/[id]/ideas/route.ts
    apps/web/app/api/governance/deposit/route.ts
    apps/web/app/api/governance/votes/route.ts
  </files>
  <action>
    Follow the existing API pattern from `/api/contributions/[wallet]/route.ts` and `/api/directory/route.ts` (pagination, error handling, Prisma queries).

    1. `GET /api/governance/rounds` (apps/web/app/api/governance/rounds/route.ts):
       - Query params: `status` (optional filter), `page` (default 1), `limit` (default 10, max 50)
       - Prisma: `ideaRound.findMany` with status filter, orderBy createdAt desc, include `_count: { ideas: true }`
       - Also do a count query for pagination
       - Return: `{ rounds: IdeaRound[], total, page, limit }`
       - Also include a `POST` handler for creating rounds with off-chain data:
         - Body: `{ roundIndex, onChainAddress, title, description, contentHash, submissionStart, submissionEnd, votingEnd, quorumType }`
         - Protected: require auth session (import from auth config)
         - Upsert by onChainAddress (idempotent -- webhook may arrive first)
       - BigInt fields serialized as strings (project convention)

    2. `GET /api/governance/rounds/:id` (apps/web/app/api/governance/rounds/[id]/route.ts):
       - Param: `id` (the cuid or roundIndex)
       - Prisma: `ideaRound.findUnique` with include `{ ideas: { include: { _count: { select: { votes: true } } } } }`
       - Return round with nested ideas and vote counts
       - Handle: compute `effectiveStatus` by comparing timestamps to now (for stale-status display fix per Research Pitfall 4)

    3. `GET /api/governance/rounds/:id/ideas` (apps/web/app/api/governance/rounds/[id]/ideas/route.ts):
       - Params: `id` (round ID), query: `page`, `limit`, `sort` (newest, most_votes)
       - Prisma: `idea.findMany` where roundId = id, orderBy based on sort param
       - Return: `{ ideas: Idea[], total, page, limit }`
       - Also include a `POST` handler for submitting idea off-chain data:
         - Body: `{ ideaIndex, onChainAddress, title, description, contentHash, transactionSignature }`
         - Protected: require auth session
         - Upsert by onChainAddress

    4. `GET /api/governance/deposit` (apps/web/app/api/governance/deposit/route.ts):
       - Query param: `wallet` (required)
       - Prisma: `voteDeposit.findUnique` where walletAddress = wallet
       - Return deposit info with computed `isEligible` (now >= eligibleAt)
       - Return null/empty if no deposit exists
       - BigInt depositedAmount serialized as string

    5. `GET /api/governance/votes` (apps/web/app/api/governance/votes/route.ts):
       - Query params: `ideaId` (optional), `wallet` (optional), `page`, `limit`
       - If ideaId: return all votes for that idea (satisfies GOVR-09)
       - If wallet: return all votes by that wallet (satisfies GOVR-10)
       - Prisma: `vote.findMany` with appropriate where clause, include idea relation for context
       - Return: `{ votes: VoteRecord[], total, page, limit }`
       - BigInt weight serialized as string

    For all endpoints:
    - Use `NextRequest` and `NextResponse` from `next/server`
    - Import Prisma from `@/lib/prisma` (existing singleton)
    - Wrap in try/catch with 500 error responses
    - Handle database unavailability gracefully (return empty arrays with 200, per project convention from 01-04)
  </action>
  <verify>
    Verify all route files compile: `cd apps/web && npx tsc --noEmit`. Check that the API routes follow Next.js App Router conventions (named exports GET/POST).
  </verify>
  <done>5 API route files created. GET endpoints return paginated governance data. POST endpoints accept off-chain content for rounds and ideas. All compile without TypeScript errors.</done>
</task>

</tasks>

<verification>
1. Webhook handler processes both contribution and governance events
2. Governance indexer creates/updates Prisma records for all governance instruction types
3. `GET /api/governance/rounds` returns paginated rounds with idea counts
4. `GET /api/governance/rounds/:id` returns single round with ideas
5. `GET /api/governance/rounds/:id/ideas` returns paginated ideas with vote tallies
6. `GET /api/governance/deposit?wallet=...` returns deposit status
7. `GET /api/governance/votes?ideaId=...` returns vote history
8. All BigInt values serialized as strings
9. POST endpoints support off-chain content creation (idempotent)
</verification>

<success_criteria>
- Helius webhook routes governance transactions to governance indexer
- 5 API endpoints return correct governance data with pagination
- Off-chain content (title/description) can be submitted via POST
- On-chain events sync to database via webhook
- All endpoints handle database errors gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/03-governance-idea-rounds/03-05-SUMMARY.md`
</output>
