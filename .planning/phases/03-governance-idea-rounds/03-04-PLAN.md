---
phase: 03-governance-idea-rounds
plan: 04
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - programs/gsd-hub/src/instructions/deposit_tokens.rs
  - programs/gsd-hub/src/instructions/withdraw_tokens.rs
  - programs/gsd-hub/src/instructions/cast_vote.rs
  - programs/gsd-hub/src/instructions/relinquish_vote.rs
  - programs/gsd-hub/src/instructions/veto_idea.rs
  - programs/gsd-hub/src/instructions/mod.rs
  - programs/gsd-hub/src/lib.rs
  - programs/gsd-hub/tests/governance-voting.test.ts
autonomous: true

must_haves:
  truths:
    - "User can deposit $GSD tokens into escrow and gain voting weight after 7-day timelock"
    - "User can vote Yes/No/Abstain on ideas during voting period with deposited token weight"
    - "Double-voting on same idea is prevented by VoteRecord PDA uniqueness"
    - "User cannot withdraw while active votes exist"
    - "User can relinquish votes after round closes to enable withdrawal"
    - "Veto council (multisig vault) can veto an approved idea"
    - "Vote weights are correctly tallied on the Idea account"
  artifacts:
    - path: "programs/gsd-hub/src/instructions/deposit_tokens.rs"
      provides: "DepositTokens instruction -- transfers $GSD to escrow, sets timelock"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/src/instructions/withdraw_tokens.rs"
      provides: "WithdrawTokens instruction -- returns tokens when no active votes"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/src/instructions/cast_vote.rs"
      provides: "CastVote instruction -- creates VoteRecord, tallies on Idea"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/src/instructions/relinquish_vote.rs"
      provides: "RelinquishVote instruction -- decrements active_votes after round closes"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/src/instructions/veto_idea.rs"
      provides: "VetoIdea instruction -- veto council blocks malicious idea"
      contains: "pub fn handler"
    - path: "programs/gsd-hub/tests/governance-voting.test.ts"
      provides: "Bankrun tests for voting lifecycle"
      contains: "describe.*voting"
  key_links:
    - from: "programs/gsd-hub/src/instructions/deposit_tokens.rs"
      to: "programs/gsd-hub/src/state/vote_deposit.rs"
      via: "Creates/updates VoteDeposit PDA, transfers to escrow ATA"
      pattern: "anchor_spl::token::transfer"
    - from: "programs/gsd-hub/src/instructions/cast_vote.rs"
      to: "programs/gsd-hub/src/state/vote_record.rs"
      via: "Init VoteRecord PDA, increment active_votes"
      pattern: "vote_record.*init"
    - from: "programs/gsd-hub/src/instructions/cast_vote.rs"
      to: "programs/gsd-hub/src/state/idea.rs"
      via: "Tally vote weight on Idea account"
      pattern: "idea\\.yes_weight|idea\\.no_weight|idea\\.abstain_weight"
    - from: "programs/gsd-hub/src/instructions/veto_idea.rs"
      to: "programs/gsd-hub/src/state/governance_config.rs"
      via: "Validates veto_authority matches config"
      pattern: "governance_config\\.veto_authority"
---

<objective>
Implement the voting and token escrow instructions in the gsd-hub Anchor program: token deposit/withdrawal with timelock, vote casting with weight tallying, vote relinquishment, and veto council functionality. Includes bankrun integration tests.

Purpose: These instructions satisfy GOVR-02 through GOVR-08 (token deposit for voting weight, Yes/No/Abstain voting, 7-day timelock, active vote withdrawal restriction, graduated quorum support, veto council). Combined with Plan 03's round lifecycle, this completes all on-chain governance logic.

Output: 5 new instruction files, updated lib.rs with handlers, bankrun test suite for voting mechanics.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-governance-idea-rounds/03-RESEARCH.md
@.planning/phases/03-governance-idea-rounds/03-01-SUMMARY.md
@.planning/phases/03-governance-idea-rounds/03-03-SUMMARY.md

@programs/gsd-hub/src/lib.rs
@programs/gsd-hub/src/errors.rs
@programs/gsd-hub/src/state/mod.rs
@programs/gsd-hub/src/state/vote_deposit.rs
@programs/gsd-hub/src/state/vote_record.rs
@programs/gsd-hub/src/state/governance_config.rs
@programs/gsd-hub/src/instructions/mod.rs
@programs/gsd-hub/tests/governance-rounds.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement deposit, withdraw, cast_vote, relinquish_vote, and veto_idea instructions</name>
  <files>
    programs/gsd-hub/src/instructions/deposit_tokens.rs
    programs/gsd-hub/src/instructions/withdraw_tokens.rs
    programs/gsd-hub/src/instructions/cast_vote.rs
    programs/gsd-hub/src/instructions/relinquish_vote.rs
    programs/gsd-hub/src/instructions/veto_idea.rs
    programs/gsd-hub/src/instructions/mod.rs
    programs/gsd-hub/src/lib.rs
  </files>
  <action>
    1. Create `deposit_tokens.rs`:
       - Accounts struct `DepositTokens`:
         - `governance_config`: mut, seeds = [b"governance_config"], bump = governance_config.bump (to increment total_deposited)
         - `vote_deposit`: init_if_needed, payer = depositor, space = 8 + VoteDeposit::INIT_SPACE, seeds = [b"vote_deposit", depositor.key().as_ref()], bump
         - `depositor`: Signer, mut
         - `user_token_account`: Account<TokenAccount> (user's ATA for $GSD, constraint = user_token_account.owner == depositor.key() && user_token_account.mint == governance_config.governance_token_mint)
         - `escrow_token_account`: Account<TokenAccount> (PDA-controlled escrow ATA, init_if_needed or pre-created. Use `associated_token::AssociatedToken` for creation. Seeds: standard ATA derivation for vote_deposit PDA + mint)
         - `token_program`: Program<Token>
         - `associated_token_program`: Program<AssociatedToken>
         - `system_program`: Program<System>
       - Handler args: `amount: u64`
       - Validate amount > 0 (GovernanceError::InsufficientDeposit)
       - Transfer tokens via `anchor_spl::token::transfer` from user_token_account to escrow_token_account
       - Update vote_deposit: deposited_amount += amount (checked_add), if deposit_timestamp == 0 set deposit_timestamp and eligible_at (now + governance_config.deposit_timelock)
       - Increment governance_config.total_deposited by amount
       - Set vote_deposit.bump = ctx.bumps.vote_deposit
       - Set vote_deposit.authority = depositor.key()
       - Use `anchor_spl::token::{Token, TokenAccount, Transfer, transfer}` and `anchor_spl::associated_token::AssociatedToken`

       **Important escrow design:** The escrow token account should be an ATA owned by the vote_deposit PDA. To transfer out (withdraw), sign with vote_deposit PDA seeds. Alternative simpler approach: use a single program-level escrow vault. For per-user tracking, the simpler approach is a single global escrow vault ATA owned by the governance_config PDA, with amounts tracked in VoteDeposit accounts. This avoids per-user ATA creation complexity.

       **Recommended: Global escrow vault approach:**
       - `escrow_token_account`: mut, token::mint = governance_config.governance_token_mint, token::authority = governance_config (the governance config PDA controls the vault)
       - Use `init_if_needed` with `associated_token::create` for first deposit, or require a separate init step
       - For withdraw, sign with governance_config PDA seeds

    2. Create `withdraw_tokens.rs`:
       - Accounts struct `WithdrawTokens`:
         - `governance_config`: mut, seeds = [b"governance_config"], bump = governance_config.bump
         - `vote_deposit`: mut, seeds = [b"vote_deposit", depositor.key().as_ref()], bump = vote_deposit.bump, constraint = vote_deposit.active_votes == 0 @ GovernanceError::ActiveVotesExist
         - `depositor`: Signer, mut
         - `user_token_account`: mut Account<TokenAccount>
         - `escrow_token_account`: mut Account<TokenAccount>
         - `token_program`: Program<Token>
       - Handler args: `amount: u64`
       - Validate amount <= vote_deposit.deposited_amount
       - Transfer tokens from escrow to user via `transfer` with PDA signer seeds (governance_config seeds + bump)
       - Decrement vote_deposit.deposited_amount and governance_config.total_deposited
       - If deposited_amount reaches 0, reset deposit_timestamp and eligible_at to 0

    3. Create `cast_vote.rs` (following research Pattern 3 closely):
       - Accounts struct `CastVote`:
         - `idea`: mut, seeds = [b"idea", round.key().as_ref(), &idea.idea_index.to_le_bytes()], bump = idea.bump
         - `round`: Account<IdeaRound>, constraint = round.status == RoundStatus::Voting @ GovernanceError::RoundNotInVotingState
         - `vote_record`: init, payer = voter, space = 8 + VoteRecord::INIT_SPACE, seeds = [b"vote_record", voter.key().as_ref(), idea.key().as_ref()], bump
         - `vote_deposit`: mut, seeds = [b"vote_deposit", voter.key().as_ref()], bump = vote_deposit.bump, constraint = vote_deposit.deposited_amount > 0 @ GovernanceError::NoDeposit, constraint = Clock::get()?.unix_timestamp >= vote_deposit.eligible_at @ GovernanceError::TokensNotYetEligible
         - `voter`: Signer, mut
         - `system_program`: Program<System>
       - Handler args: `vote: VoteChoice`
       - Validate: clock.unix_timestamp < round.voting_end (GovernanceError::VotingPeriodEnded)
       - Weight = vote_deposit.deposited_amount
       - Set all vote_record fields
       - Update idea tallies based on vote choice (checked_add for overflow safety)
       - Increment idea.voter_count
       - Increment vote_deposit.active_votes

    4. Create `relinquish_vote.rs`:
       - Accounts struct `RelinquishVote`:
         - `round`: Account<IdeaRound>, constraint = round.status == RoundStatus::Closed @ GovernanceError::RoundStillActive
         - `vote_record`: Account<VoteRecord>, constraint = vote_record.voter == voter.key(), constraint = vote_record.round == round.key()
         - `vote_deposit`: mut, seeds = [b"vote_deposit", voter.key().as_ref()], bump = vote_deposit.bump
         - `voter`: Signer
       - Handler: Decrement vote_deposit.active_votes by 1 (checked_sub)
       - Note: vote_record is NOT closed (kept for history). To close it and reclaim rent, a separate close instruction could be added later.

    5. Create `veto_idea.rs`:
       - Accounts struct `VetoIdea`:
         - `idea`: mut, seeds = [b"idea", round.key().as_ref(), &idea.idea_index.to_le_bytes()], bump = idea.bump
         - `round`: Account<IdeaRound>
         - `governance_config`: Account<GovernanceConfig>
         - `veto_authority`: Signer, constraint = veto_authority.key() == governance_config.veto_authority @ GovernanceError::UnauthorizedVeto
       - Handler: Set idea.status = IdeaStatus::Vetoed
       - Validate idea status is Submitted or Approved (not already Vetoed or Rejected) via GovernanceError::NotVetoable

    6. Update `instructions/mod.rs` -- add the 5 new modules and pub use their account structs.

    7. Update `lib.rs` -- add 5 new instruction handlers:
       - `deposit_tokens(ctx, amount: u64)`
       - `withdraw_tokens(ctx, amount: u64)`
       - `cast_vote(ctx, vote: VoteChoice)`
       - `relinquish_vote(ctx)`
       - `veto_idea(ctx)`
  </action>
  <verify>Run `anchor build` -- must compile successfully with all 5 new instructions in the IDL.</verify>
  <done>All 5 voting instruction files compile. lib.rs exports all handlers. IDL includes deposit_tokens, withdraw_tokens, cast_vote, relinquish_vote, veto_idea.</done>
</task>

<task type="auto">
  <name>Task 2: Bankrun tests for voting and token escrow mechanics</name>
  <files>programs/gsd-hub/tests/governance-voting.test.ts</files>
  <action>
    Create `programs/gsd-hub/tests/governance-voting.test.ts`:

    Setup (shared with round lifecycle -- can reference governance-rounds.test.ts pattern):
    - startAnchor + BankrunProvider + Program<GsdHub>
    - Create admin keypair, airdrop SOL
    - Create $GSD test token mint (using @solana/spl-token createMint)
    - Create veto authority keypair
    - Init governance config
    - Create a round (submission_start = now, submission_end = now + 100, voting_end = now + 200)
    - Create voter keypair, airdrop SOL
    - Mint test $GSD tokens to voter (using mintTo from @solana/spl-token)
    - Submit an idea to the round

    Test cases:

    1. "deposits tokens for voting weight":
       - Call `deposit_tokens` with amount = 1_000_000
       - Fetch VoteDeposit PDA -- assert deposited_amount = 1_000_000, eligible_at = now + 604800
       - Fetch escrow token account -- assert balance = 1_000_000
       - Assert governance_config.total_deposited = 1_000_000

    2. "rejects vote before timelock expires":
       - Warp time past submission_end (round enters Voting via transition)
       - Transition round to Voting
       - Attempt cast_vote -- expect TokensNotYetEligible error

    3. "casts vote after timelock":
       - Warp time past eligible_at (7 days after deposit) but still within voting_end
       - Adjust round timestamps so voting period is still open at this time
       - Call `cast_vote` with VoteChoice::Yes
       - Fetch VoteRecord PDA -- assert voter, idea, vote = Yes, weight = 1_000_000
       - Fetch Idea -- assert yes_weight = 1_000_000, voter_count = 1
       - Fetch VoteDeposit -- assert active_votes = 1

    4. "prevents double voting on same idea":
       - Attempt `cast_vote` again on same idea -- expect "already in use" error (PDA already exists)

    5. "prevents withdrawal with active votes":
       - Call `withdraw_tokens` with amount = 1_000_000 -- expect ActiveVotesExist error

    6. "relinquishes vote after round closes":
       - Warp time past voting_end
       - Transition round to Closed
       - Call `relinquish_vote`
       - Fetch VoteDeposit -- assert active_votes = 0

    7. "withdraws tokens after relinquishing":
       - Call `withdraw_tokens` with amount = 1_000_000
       - Fetch user token account -- assert balance restored
       - Fetch VoteDeposit -- assert deposited_amount = 0
       - Assert governance_config.total_deposited = 0

    8. "veto council can veto an idea":
       - Set up fresh round + idea + vote scenario
       - Call `veto_idea` with veto_authority signer
       - Fetch Idea -- assert status = Vetoed

    9. "non-veto authority cannot veto":
       - Attempt `veto_idea` with random signer -- expect UnauthorizedVeto

    **Important timing note:** Because the 7-day timelock makes test 3 require large time warps, create the test round with submission_end and voting_end far enough in the future. For example:
    - submission_end = now + 604800 + 100 (7 days + buffer)
    - voting_end = now + 604800 + 200
    - This way, after warping past the 7-day timelock, the voting period is still open.

    For SPL token operations in bankrun, use `@solana/spl-token` library functions (createMint, createAssociatedTokenAccount, mintTo) with the bankrun provider's connection.

    Use BN.js for u64/i64 args (project convention from 02-03).
  </action>
  <verify>Run `anchor test` or the specific test file -- all 9 test cases pass.</verify>
  <done>All 9 bankrun tests pass: deposit, timelock enforcement, vote casting, double-vote prevention, withdrawal restriction, vote relinquishment, withdrawal, veto authority, and unauthorized veto rejection.</done>
</task>

</tasks>

<verification>
1. `anchor build` succeeds with all 10 governance instructions (5 from plan-03 + 5 from this plan)
2. Generated IDL includes deposit_tokens, withdraw_tokens, cast_vote, relinquish_vote, veto_idea
3. All 9 bankrun test cases pass
4. Token escrow correctly tracks deposits and prevents withdrawal during active votes
5. VoteRecord PDA uniqueness prevents double-voting
6. Veto authority validation works correctly
</verification>

<success_criteria>
- User can deposit $GSD tokens and gain voting weight after timelock
- User can vote Yes/No/Abstain with weight equal to deposited amount
- Double-voting prevented by PDA uniqueness constraint
- Withdrawal blocked while active_votes > 0
- Relinquish vote decrements active_votes after round closes
- Veto council (matching governance_config.veto_authority) can veto ideas
- Non-authorities cannot veto
- All arithmetic uses checked operations
</success_criteria>

<output>
After completion, create `.planning/phases/03-governance-idea-rounds/03-04-SUMMARY.md`
</output>
